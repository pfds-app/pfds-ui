/* tslint:disable */
/* eslint-disable */
/**
 * Jfds Api
 * Jfds
 *
 * The version of the OpenAPI document: 0.0.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from "./configuration";
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from "axios";
import globalAxios from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "./common";
import type { RequestArgs } from "./base";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  BaseAPI,
  RequiredError,
  operationServerMap,
} from "./base";

/**
 *
 * @export
 * @interface Activity
 */
export interface Activity {
  /**
   *
   * @type {string}
   * @memberof Activity
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Activity
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof Activity
   */
  place: string;
  /**
   *
   * @type {string}
   * @memberof Activity
   */
  beginDate: string;
  /**
   *
   * @type {string}
   * @memberof Activity
   */
  endDate: string;
  /**
   *
   * @type {string}
   * @memberof Activity
   */
  description: string;
  /**
   *
   * @type {string}
   * @memberof Activity
   */
  roleType: ActivityRoleTypeEnum;
  /**
   *
   * @type {string}
   * @memberof Activity
   */
  organisatorRole: ActivityOrganisatorRoleEnum;
  /**
   *
   * @type {string}
   * @memberof Activity
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof Activity
   */
  updatedAt: string;
}

export const ActivityRoleTypeEnum = {
  All: "ALL",
  Manager: "MANAGER",
} as const;

export type ActivityRoleTypeEnum =
  (typeof ActivityRoleTypeEnum)[keyof typeof ActivityRoleTypeEnum];
export const ActivityOrganisatorRoleEnum = {
  Admin: "ADMIN",
  RegionManager: "REGION_MANAGER",
  CommitteeManager: "COMMITTEE_MANAGER",
  AssociationManager: "ASSOCIATION_MANAGER",
  SimpleUser: "SIMPLE_USER",
} as const;

export type ActivityOrganisatorRoleEnum =
  (typeof ActivityOrganisatorRoleEnum)[keyof typeof ActivityOrganisatorRoleEnum];

/**
 *
 * @export
 * @interface ApiResponseError
 */
export interface ApiResponseError {
  /**
   *
   * @type {number}
   * @memberof ApiResponseError
   */
  statusCode: number;
  /**
   *
   * @type {string}
   * @memberof ApiResponseError
   */
  message: string;
  /**
   *
   * @type {string}
   * @memberof ApiResponseError
   */
  error: string;
}
/**
 *
 * @export
 * @interface Association
 */
export interface Association {
  /**
   *
   * @type {string}
   * @memberof Association
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Association
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof Association
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof Association
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof Association
   */
  updatedAt: string;
}
/**
 *
 * @export
 * @interface Committee
 */
export interface Committee {
  /**
   *
   * @type {string}
   * @memberof Committee
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Committee
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof Committee
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof Committee
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof Committee
   */
  updatedAt: string;
}
/**
 *
 * @export
 * @interface Count
 */
export interface Count {
  /**
   *
   * @type {number}
   * @memberof Count
   */
  value: number;
}
/**
 *
 * @export
 * @interface CreatePresence
 */
export interface CreatePresence {
  /**
   *
   * @type {string}
   * @memberof CreatePresence
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof CreatePresence
   */
  activityId: string;
  /**
   *
   * @type {string}
   * @memberof CreatePresence
   */
  userId: string;
  /**
   *
   * @type {string}
   * @memberof CreatePresence
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof CreatePresence
   */
  updatedAt: string;
}
/**
 *
 * @export
 * @interface CreateUser
 */
export interface CreateUser {
  /**
   *
   * @type {string}
   * @memberof CreateUser
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof CreateUser
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof CreateUser
   */
  username: string;
  /**
   *
   * @type {string}
   * @memberof CreateUser
   */
  firstName: string;
  /**
   *
   * @type {string}
   * @memberof CreateUser
   */
  lastName: string;
  /**
   *
   * @type {string}
   * @memberof CreateUser
   */
  birthDate: string;
  /**
   *
   * @type {string}
   * @memberof CreateUser
   */
  address: string;
  /**
   *
   * @type {string}
   * @memberof CreateUser
   */
  gender: CreateUserGenderEnum;
  /**
   *
   * @type {string}
   * @memberof CreateUser
   */
  role: CreateUserRoleEnum;
  /**
   *
   * @type {string}
   * @memberof CreateUser
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof CreateUser
   */
  updatedAt: string;
  /**
   *
   * @type {string}
   * @memberof CreateUser
   */
  nic?: string;
  /**
   *
   * @type {string}
   * @memberof CreateUser
   */
  apv?: string;
  /**
   *
   * @type {string}
   * @memberof CreateUser
   */
  responsabilityId?: string;
  /**
   *
   * @type {string}
   * @memberof CreateUser
   */
  regionId?: string;
  /**
   *
   * @type {string}
   * @memberof CreateUser
   */
  committeeId?: string;
  /**
   *
   * @type {string}
   * @memberof CreateUser
   */
  associationId?: string;
  /**
   *
   * @type {string}
   * @memberof CreateUser
   */
  sacramentId?: string;
  /**
   *
   * @type {string}
   * @memberof CreateUser
   */
  password: string;
}

export const CreateUserGenderEnum = {
  Male: "MALE",
  Female: "FEMALE",
} as const;

export type CreateUserGenderEnum =
  (typeof CreateUserGenderEnum)[keyof typeof CreateUserGenderEnum];
export const CreateUserRoleEnum = {
  Admin: "ADMIN",
  RegionManager: "REGION_MANAGER",
  CommitteeManager: "COMMITTEE_MANAGER",
  AssociationManager: "ASSOCIATION_MANAGER",
  SimpleUser: "SIMPLE_USER",
} as const;

export type CreateUserRoleEnum =
  (typeof CreateUserRoleEnum)[keyof typeof CreateUserRoleEnum];

/**
 *
 * @export
 * @interface CrupdateTicket
 */
export interface CrupdateTicket {
  /**
   *
   * @type {string}
   * @memberof CrupdateTicket
   */
  id: string;
  /**
   *
   * @type {number}
   * @memberof CrupdateTicket
   */
  fromNumber: number;
  /**
   *
   * @type {number}
   * @memberof CrupdateTicket
   */
  toNumber: number;
  /**
   *
   * @type {string}
   * @memberof CrupdateTicket
   */
  operationId: string;
  /**
   *
   * @type {string}
   * @memberof CrupdateTicket
   */
  staffId: string;
  /**
   *
   * @type {string}
   * @memberof CrupdateTicket
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof CrupdateTicket
   */
  updatedAt: string;
}
/**
 *
 * @export
 * @interface DeletedRole
 */
export interface DeletedRole {
  /**
   *
   * @type {string}
   * @memberof DeletedRole
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof DeletedRole
   */
  role: DeletedRoleRoleEnum;
  /**
   *
   * @type {string}
   * @memberof DeletedRole
   */
  createdAt: string;
  /**
   *
   * @type {User}
   * @memberof DeletedRole
   */
  user: User;
}

export const DeletedRoleRoleEnum = {
  Admin: "ADMIN",
  RegionManager: "REGION_MANAGER",
  CommitteeManager: "COMMITTEE_MANAGER",
  AssociationManager: "ASSOCIATION_MANAGER",
  SimpleUser: "SIMPLE_USER",
} as const;

export type DeletedRoleRoleEnum =
  (typeof DeletedRoleRoleEnum)[keyof typeof DeletedRoleRoleEnum];

/**
 *
 * @export
 * @interface Dummy
 */
export interface Dummy {
  /**
   *
   * @type {string}
   * @memberof Dummy
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Dummy
   */
  name: string;
}
/**
 *
 * @export
 * @interface Event
 */
export interface Event {
  /**
   *
   * @type {string}
   * @memberof Event
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Event
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof Event
   */
  place: string;
  /**
   *
   * @type {string}
   * @memberof Event
   */
  beginDate: string;
  /**
   *
   * @type {string}
   * @memberof Event
   */
  endDate: string;
  /**
   *
   * @type {string}
   * @memberof Event
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof Event
   */
  updatedAt: string;
}
/**
 *
 * @export
 * @interface Ledger
 */
export interface Ledger {
  /**
   *
   * @type {string}
   * @memberof Ledger
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Ledger
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof Ledger
   */
  ledgerDate: string;
  /**
   *
   * @type {string}
   * @memberof Ledger
   */
  mouvementType: LedgerMouvementTypeEnum;
  /**
   *
   * @type {string}
   * @memberof Ledger
   */
  price: string;
  /**
   *
   * @type {string}
   * @memberof Ledger
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof Ledger
   */
  updatedAt: string;
}

export const LedgerMouvementTypeEnum = {
  In: "IN",
  Out: "OUT",
} as const;

export type LedgerMouvementTypeEnum =
  (typeof LedgerMouvementTypeEnum)[keyof typeof LedgerMouvementTypeEnum];

/**
 *
 * @export
 * @interface LedgerStat
 */
export interface LedgerStat {
  /**
   *
   * @type {string}
   * @memberof LedgerStat
   */
  count: string;
  /**
   *
   * @type {number}
   * @memberof LedgerStat
   */
  month: number;
}
/**
 *
 * @export
 * @interface Operation
 */
export interface Operation {
  /**
   *
   * @type {string}
   * @memberof Operation
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Operation
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof Operation
   */
  numberOfTickets: number;
  /**
   *
   * @type {string}
   * @memberof Operation
   */
  ticketPrice: string;
  /**
   *
   * @type {string}
   * @memberof Operation
   */
  description: string;
  /**
   *
   * @type {string}
   * @memberof Operation
   */
  operationDate: string;
  /**
   *
   * @type {string}
   * @memberof Operation
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof Operation
   */
  updatedAt: string;
}
/**
 *
 * @export
 * @interface OperationResult
 */
export interface OperationResult {
  /**
   *
   * @type {Operation}
   * @memberof OperationResult
   */
  operation: Operation;
  /**
   *
   * @type {number}
   * @memberof OperationResult
   */
  numberOfDistributed: number;
  /**
   *
   * @type {string}
   * @memberof OperationResult
   */
  sumOfDistributed: string;
}
/**
 *
 * @export
 * @interface PayedTicket
 */
export interface PayedTicket {
  /**
   *
   * @type {string}
   * @memberof PayedTicket
   */
  id: string;
  /**
   *
   * @type {number}
   * @memberof PayedTicket
   */
  ticketNumber: number;
  /**
   *
   * @type {string}
   * @memberof PayedTicket
   */
  ticketId: string;
  /**
   *
   * @type {boolean}
   * @memberof PayedTicket
   */
  isPayed: boolean;
  /**
   *
   * @type {boolean}
   * @memberof PayedTicket
   */
  isDistributed: boolean;
  /**
   *
   * @type {string}
   * @memberof PayedTicket
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof PayedTicket
   */
  updatedAt: string;
}
/**
 *
 * @export
 * @interface Presence
 */
export interface Presence {
  /**
   *
   * @type {string}
   * @memberof Presence
   */
  id: string;
  /**
   *
   * @type {Activity}
   * @memberof Presence
   */
  activity: Activity;
  /**
   *
   * @type {User}
   * @memberof Presence
   */
  user: User;
  /**
   *
   * @type {string}
   * @memberof Presence
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof Presence
   */
  updatedAt: string;
}
/**
 *
 * @export
 * @interface PresenceStatus
 */
export interface PresenceStatus {
  /**
   *
   * @type {User}
   * @memberof PresenceStatus
   */
  user: User;
  /**
   *
   * @type {boolean}
   * @memberof PresenceStatus
   */
  isPresent: boolean;
}
/**
 *
 * @export
 * @interface Region
 */
export interface Region {
  /**
   *
   * @type {string}
   * @memberof Region
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Region
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof Region
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof Region
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof Region
   */
  updatedAt: string;
}
/**
 *
 * @export
 * @interface Responsability
 */
export interface Responsability {
  /**
   *
   * @type {string}
   * @memberof Responsability
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Responsability
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof Responsability
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof Responsability
   */
  updatedAt: string;
}
/**
 *
 * @export
 * @interface Sacrament
 */
export interface Sacrament {
  /**
   *
   * @type {string}
   * @memberof Sacrament
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Sacrament
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof Sacrament
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof Sacrament
   */
  updatedAt: string;
}
/**
 *
 * @export
 * @interface SigninByRole
 */
export interface SigninByRole {
  /**
   *
   * @type {string}
   * @memberof SigninByRole
   */
  role: string;
  /**
   *
   * @type {string}
   * @memberof SigninByRole
   */
  firstName: string;
  /**
   *
   * @type {string}
   * @memberof SigninByRole
   */
  lastName: string;
  /**
   *
   * @type {string}
   * @memberof SigninByRole
   */
  responsabilityId: string;
  /**
   *
   * @type {string}
   * @memberof SigninByRole
   */
  committeeId: string;
  /**
   *
   * @type {string}
   * @memberof SigninByRole
   */
  associationId: string;
  /**
   *
   * @type {string}
   * @memberof SigninByRole
   */
  regionId: string;
}
/**
 *
 * @export
 * @interface SigninPayload
 */
export interface SigninPayload {
  /**
   *
   * @type {string}
   * @memberof SigninPayload
   */
  password: string;
  /**
   *
   * @type {string}
   * @memberof SigninPayload
   */
  username: string;
}
/**
 *
 * @export
 * @interface SignupPayload
 */
export interface SignupPayload {
  /**
   *
   * @type {string}
   * @memberof SignupPayload
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof SignupPayload
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof SignupPayload
   */
  username: string;
  /**
   *
   * @type {string}
   * @memberof SignupPayload
   */
  firstName: string;
  /**
   *
   * @type {string}
   * @memberof SignupPayload
   */
  lastName: string;
  /**
   *
   * @type {string}
   * @memberof SignupPayload
   */
  birthDate: string;
  /**
   *
   * @type {string}
   * @memberof SignupPayload
   */
  address: string;
  /**
   *
   * @type {string}
   * @memberof SignupPayload
   */
  gender: SignupPayloadGenderEnum;
  /**
   *
   * @type {string}
   * @memberof SignupPayload
   */
  role: SignupPayloadRoleEnum;
  /**
   *
   * @type {string}
   * @memberof SignupPayload
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof SignupPayload
   */
  updatedAt: string;
  /**
   *
   * @type {string}
   * @memberof SignupPayload
   */
  nic?: string;
  /**
   *
   * @type {string}
   * @memberof SignupPayload
   */
  apv?: string;
  /**
   *
   * @type {string}
   * @memberof SignupPayload
   */
  responsabilityId?: string;
  /**
   *
   * @type {string}
   * @memberof SignupPayload
   */
  regionId?: string;
  /**
   *
   * @type {string}
   * @memberof SignupPayload
   */
  committeeId?: string;
  /**
   *
   * @type {string}
   * @memberof SignupPayload
   */
  associationId?: string;
  /**
   *
   * @type {string}
   * @memberof SignupPayload
   */
  sacramentId?: string;
  /**
   *
   * @type {string}
   * @memberof SignupPayload
   */
  password: string;
  /**
   *
   * @type {string}
   * @memberof SignupPayload
   */
  adminApiKey: string;
}

export const SignupPayloadGenderEnum = {
  Male: "MALE",
  Female: "FEMALE",
} as const;

export type SignupPayloadGenderEnum =
  (typeof SignupPayloadGenderEnum)[keyof typeof SignupPayloadGenderEnum];
export const SignupPayloadRoleEnum = {
  Admin: "ADMIN",
  RegionManager: "REGION_MANAGER",
  CommitteeManager: "COMMITTEE_MANAGER",
  AssociationManager: "ASSOCIATION_MANAGER",
  SimpleUser: "SIMPLE_USER",
} as const;

export type SignupPayloadRoleEnum =
  (typeof SignupPayloadRoleEnum)[keyof typeof SignupPayloadRoleEnum];

/**
 *
 * @export
 * @interface Ticket
 */
export interface Ticket {
  /**
   *
   * @type {string}
   * @memberof Ticket
   */
  id: string;
  /**
   *
   * @type {number}
   * @memberof Ticket
   */
  fromNumber: number;
  /**
   *
   * @type {number}
   * @memberof Ticket
   */
  toNumber: number;
  /**
   *
   * @type {Operation}
   * @memberof Ticket
   */
  operation: Operation;
  /**
   *
   * @type {User}
   * @memberof Ticket
   */
  staff: User;
  /**
   *
   * @type {string}
   * @memberof Ticket
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof Ticket
   */
  updatedAt: string;
}
/**
 *
 * @export
 * @interface TicketStatus
 */
export interface TicketStatus {
  /**
   *
   * @type {Ticket}
   * @memberof TicketStatus
   */
  ticket: Ticket;
  /**
   *
   * @type {number}
   * @memberof TicketStatus
   */
  numberOfTickets: number;
  /**
   *
   * @type {number}
   * @memberof TicketStatus
   */
  numberOfPayedTickets: number;
  /**
   *
   * @type {number}
   * @memberof TicketStatus
   */
  numberOfNotPayedTickets: number;
  /**
   *
   * @type {number}
   * @memberof TicketStatus
   */
  pourcentageOfPayedTickets: number;
  /**
   *
   * @type {number}
   * @memberof TicketStatus
   */
  pourcentageOfNotPayedTickets: number;
  /**
   *
   * @type {string}
   * @memberof TicketStatus
   */
  notPayedAmount: string;
  /**
   *
   * @type {string}
   * @memberof TicketStatus
   */
  payedAmount: string;
}
/**
 *
 * @export
 * @interface UpdateUser
 */
export interface UpdateUser {
  /**
   *
   * @type {string}
   * @memberof UpdateUser
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof UpdateUser
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof UpdateUser
   */
  username: string;
  /**
   *
   * @type {string}
   * @memberof UpdateUser
   */
  firstName: string;
  /**
   *
   * @type {string}
   * @memberof UpdateUser
   */
  lastName: string;
  /**
   *
   * @type {string}
   * @memberof UpdateUser
   */
  birthDate: string;
  /**
   *
   * @type {string}
   * @memberof UpdateUser
   */
  address: string;
  /**
   *
   * @type {string}
   * @memberof UpdateUser
   */
  gender: UpdateUserGenderEnum;
  /**
   *
   * @type {string}
   * @memberof UpdateUser
   */
  role: UpdateUserRoleEnum;
  /**
   *
   * @type {string}
   * @memberof UpdateUser
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof UpdateUser
   */
  updatedAt: string;
  /**
   *
   * @type {string}
   * @memberof UpdateUser
   */
  nic?: string;
  /**
   *
   * @type {string}
   * @memberof UpdateUser
   */
  apv?: string;
  /**
   *
   * @type {string}
   * @memberof UpdateUser
   */
  responsabilityId?: string;
  /**
   *
   * @type {string}
   * @memberof UpdateUser
   */
  regionId?: string;
  /**
   *
   * @type {string}
   * @memberof UpdateUser
   */
  committeeId?: string;
  /**
   *
   * @type {string}
   * @memberof UpdateUser
   */
  associationId?: string;
  /**
   *
   * @type {string}
   * @memberof UpdateUser
   */
  sacramentId?: string;
}

export const UpdateUserGenderEnum = {
  Male: "MALE",
  Female: "FEMALE",
} as const;

export type UpdateUserGenderEnum =
  (typeof UpdateUserGenderEnum)[keyof typeof UpdateUserGenderEnum];
export const UpdateUserRoleEnum = {
  Admin: "ADMIN",
  RegionManager: "REGION_MANAGER",
  CommitteeManager: "COMMITTEE_MANAGER",
  AssociationManager: "ASSOCIATION_MANAGER",
  SimpleUser: "SIMPLE_USER",
} as const;

export type UpdateUserRoleEnum =
  (typeof UpdateUserRoleEnum)[keyof typeof UpdateUserRoleEnum];

/**
 *
 * @export
 * @interface UploadeSuccessResponse
 */
export interface UploadeSuccessResponse {
  /**
   *
   * @type {string}
   * @memberof UploadeSuccessResponse
   */
  message: string;
  /**
   *
   * @type {string}
   * @memberof UploadeSuccessResponse
   */
  fileName: string;
}
/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {string}
   * @memberof User
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  username: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  firstName: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  lastName: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  birthDate: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  address: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  gender: UserGenderEnum;
  /**
   *
   * @type {string}
   * @memberof User
   */
  role: UserRoleEnum;
  /**
   *
   * @type {string}
   * @memberof User
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  updatedAt: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  nic?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  photo?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  apv?: string;
  /**
   *
   * @type {Responsability}
   * @memberof User
   */
  responsability?: Responsability;
  /**
   *
   * @type {Committee}
   * @memberof User
   */
  committee?: Committee;
  /**
   *
   * @type {Region}
   * @memberof User
   */
  region?: Region;
  /**
   *
   * @type {Association}
   * @memberof User
   */
  association?: Association;
  /**
   *
   * @type {Sacrament}
   * @memberof User
   */
  sacrament?: Sacrament;
}

export const UserGenderEnum = {
  Male: "MALE",
  Female: "FEMALE",
} as const;

export type UserGenderEnum =
  (typeof UserGenderEnum)[keyof typeof UserGenderEnum];
export const UserRoleEnum = {
  Admin: "ADMIN",
  RegionManager: "REGION_MANAGER",
  CommitteeManager: "COMMITTEE_MANAGER",
  AssociationManager: "ASSOCIATION_MANAGER",
  SimpleUser: "SIMPLE_USER",
} as const;

export type UserRoleEnum = (typeof UserRoleEnum)[keyof typeof UserRoleEnum];

/**
 *
 * @export
 * @interface UserStat
 */
export interface UserStat {
  /**
   *
   * @type {number}
   * @memberof UserStat
   */
  year: number;
  /**
   *
   * @type {number}
   * @memberof UserStat
   */
  maleCount: number;
  /**
   *
   * @type {number}
   * @memberof UserStat
   */
  femaleCount: number;
  /**
   *
   * @type {number}
   * @memberof UserStat
   */
  totalCount: number;
}
/**
 *
 * @export
 * @interface Whoami
 */
export interface Whoami {
  /**
   *
   * @type {string}
   * @memberof Whoami
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Whoami
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof Whoami
   */
  username: string;
  /**
   *
   * @type {string}
   * @memberof Whoami
   */
  firstName: string;
  /**
   *
   * @type {string}
   * @memberof Whoami
   */
  lastName: string;
  /**
   *
   * @type {string}
   * @memberof Whoami
   */
  birthDate: string;
  /**
   *
   * @type {string}
   * @memberof Whoami
   */
  address: string;
  /**
   *
   * @type {string}
   * @memberof Whoami
   */
  gender: WhoamiGenderEnum;
  /**
   *
   * @type {string}
   * @memberof Whoami
   */
  role: WhoamiRoleEnum;
  /**
   *
   * @type {string}
   * @memberof Whoami
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof Whoami
   */
  updatedAt: string;
  /**
   *
   * @type {string}
   * @memberof Whoami
   */
  nic?: string;
  /**
   *
   * @type {string}
   * @memberof Whoami
   */
  photo?: string;
  /**
   *
   * @type {string}
   * @memberof Whoami
   */
  apv?: string;
  /**
   *
   * @type {Responsability}
   * @memberof Whoami
   */
  responsability?: Responsability;
  /**
   *
   * @type {Committee}
   * @memberof Whoami
   */
  committee?: Committee;
  /**
   *
   * @type {Region}
   * @memberof Whoami
   */
  region?: Region;
  /**
   *
   * @type {Association}
   * @memberof Whoami
   */
  association?: Association;
  /**
   *
   * @type {Sacrament}
   * @memberof Whoami
   */
  sacrament?: Sacrament;
  /**
   *
   * @type {string}
   * @memberof Whoami
   */
  token: string;
}

export const WhoamiGenderEnum = {
  Male: "MALE",
  Female: "FEMALE",
} as const;

export type WhoamiGenderEnum =
  (typeof WhoamiGenderEnum)[keyof typeof WhoamiGenderEnum];
export const WhoamiRoleEnum = {
  Admin: "ADMIN",
  RegionManager: "REGION_MANAGER",
  CommitteeManager: "COMMITTEE_MANAGER",
  AssociationManager: "ASSOCIATION_MANAGER",
  SimpleUser: "SIMPLE_USER",
} as const;

export type WhoamiRoleEnum =
  (typeof WhoamiRoleEnum)[keyof typeof WhoamiRoleEnum];

/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDummies: async (
      page?: number,
      pageSize?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/dummies`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter["pageSize"] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPrivateDummies: async (
      page?: number,
      pageSize?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/dummies/private`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter["pageSize"] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ping: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ping`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDummies(
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Dummy>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDummies(
        page,
        pageSize,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["HealthApi.getDummies"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPrivateDummies(
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Dummy>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getPrivateDummies(
          page,
          pageSize,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["HealthApi.getPrivateDummies"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ping(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.ping(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["HealthApi.ping"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = HealthApiFp(configuration);
  return {
    /**
     *
     * @summary
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDummies(
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Dummy>> {
      return localVarFp
        .getDummies(page, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPrivateDummies(
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Dummy>> {
      return localVarFp
        .getPrivateDummies(page, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ping(options?: RawAxiosRequestConfig): AxiosPromise<string> {
      return localVarFp
        .ping(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
  /**
   *
   * @summary
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HealthApi
   */
  public getDummies(
    page?: number,
    pageSize?: number,
    options?: RawAxiosRequestConfig
  ) {
    return HealthApiFp(this.configuration)
      .getDummies(page, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HealthApi
   */
  public getPrivateDummies(
    page?: number,
    pageSize?: number,
    options?: RawAxiosRequestConfig
  ) {
    return HealthApiFp(this.configuration)
      .getPrivateDummies(page, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HealthApi
   */
  public ping(options?: RawAxiosRequestConfig) {
    return HealthApiFp(this.configuration)
      .ping(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * MoneysApi - axios parameter creator
 * @export
 */
export const MoneysApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary
     * @param {Array<Ledger>} ledger
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateLedgers: async (
      ledger: Array<Ledger>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'ledger' is not null or undefined
      assertParamExists("crupdateLedgers", "ledger", ledger);
      const localVarPath = `/ledgers`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        ledger,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {Array<Operation>} operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateOperations: async (
      operation: Array<Operation>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'operation' is not null or undefined
      assertParamExists("crupdateOperations", "operation", operation);
      const localVarPath = `/operations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        operation,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} operationId
     * @param {string} staffId
     * @param {Array<PayedTicket>} payedTicket
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdatePayedTickets: async (
      operationId: string,
      staffId: string,
      payedTicket: Array<PayedTicket>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'operationId' is not null or undefined
      assertParamExists("crupdatePayedTickets", "operationId", operationId);
      // verify required parameter 'staffId' is not null or undefined
      assertParamExists("crupdatePayedTickets", "staffId", staffId);
      // verify required parameter 'payedTicket' is not null or undefined
      assertParamExists("crupdatePayedTickets", "payedTicket", payedTicket);
      const localVarPath =
        `/operation/{operationId}/staffs/{staffId}/payed-tickets`
          .replace(
            `{${"operationId"}}`,
            encodeURIComponent(String(operationId))
          )
          .replace(`{${"staffId"}}`, encodeURIComponent(String(staffId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        payedTicket,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {Array<CrupdateTicket>} crupdateTicket
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateTickets: async (
      crupdateTicket: Array<CrupdateTicket>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'crupdateTicket' is not null or undefined
      assertParamExists("crupdateTickets", "crupdateTicket", crupdateTicket);
      const localVarPath = `/tickets`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        crupdateTicket,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLedgerById: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deleteLedgerById", "id", id);
      const localVarPath = `/ledgers/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteOperationById: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deleteOperationById", "id", id);
      const localVarPath = `/operations/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTicketById: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deleteTicketById", "id", id);
      const localVarPath = `/tickets/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} operationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllOperationStaffs: async (
      operationId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'operationId' is not null or undefined
      assertParamExists("getAllOperationStaffs", "operationId", operationId);
      const localVarPath = `/operations/{operationId}/staffs`.replace(
        `{${"operationId"}}`,
        encodeURIComponent(String(operationId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} operationId
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllOperationTicketsStatus: async (
      operationId: string,
      page?: number,
      pageSize?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'operationId' is not null or undefined
      assertParamExists(
        "getAllOperationTicketsStatus",
        "operationId",
        operationId
      );
      const localVarPath = `/operations/{operationId}/tickets/status`.replace(
        `{${"operationId"}}`,
        encodeURIComponent(String(operationId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter["pageSize"] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLedgerById: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getLedgerById", "id", id);
      const localVarPath = `/ledgers/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {number} [year]
     * @param {GetLedgerStatsTypeEnum} [type]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLedgerStats: async (
      year?: number,
      type?: GetLedgerStatsTypeEnum,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/ledgers/all/stats`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (year !== undefined) {
        localVarQueryParameter["year"] = year;
      }

      if (type !== undefined) {
        localVarQueryParameter["type"] = type;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {number} [year]
     * @param {number} [month]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLedgers: async (
      name?: string,
      year?: number,
      month?: number,
      page?: number,
      pageSize?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/ledgers`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (name !== undefined) {
        localVarQueryParameter["name"] = name;
      }

      if (year !== undefined) {
        localVarQueryParameter["year"] = year;
      }

      if (month !== undefined) {
        localVarQueryParameter["month"] = month;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter["pageSize"] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOperationById: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getOperationById", "id", id);
      const localVarPath = `/operations/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOperationResults: async (
      page?: number,
      pageSize?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/operations/results/all`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter["pageSize"] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} operationId
     * @param {number} ticketNumber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOperationTicketByTicketNumber: async (
      operationId: string,
      ticketNumber: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'operationId' is not null or undefined
      assertParamExists(
        "getOperationTicketByTicketNumber",
        "operationId",
        operationId
      );
      // verify required parameter 'ticketNumber' is not null or undefined
      assertParamExists(
        "getOperationTicketByTicketNumber",
        "ticketNumber",
        ticketNumber
      );
      const localVarPath = `/operation/{operationId}/tickets/{ticketNumber}`
        .replace(`{${"operationId"}}`, encodeURIComponent(String(operationId)))
        .replace(
          `{${"ticketNumber"}}`,
          encodeURIComponent(String(ticketNumber))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOperations: async (
      name?: string,
      page?: number,
      pageSize?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/operations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (name !== undefined) {
        localVarQueryParameter["name"] = name;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter["pageSize"] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} operationId
     * @param {string} staffId
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPayedTickets: async (
      operationId: string,
      staffId: string,
      page?: number,
      pageSize?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'operationId' is not null or undefined
      assertParamExists("getPayedTickets", "operationId", operationId);
      // verify required parameter 'staffId' is not null or undefined
      assertParamExists("getPayedTickets", "staffId", staffId);
      const localVarPath =
        `/operation/{operationId}/staffs/{staffId}/payed-tickets`
          .replace(
            `{${"operationId"}}`,
            encodeURIComponent(String(operationId))
          )
          .replace(`{${"staffId"}}`, encodeURIComponent(String(staffId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter["pageSize"] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTicketById: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getTicketById", "id", id);
      const localVarPath = `/tickets/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTickets: async (
      page?: number,
      pageSize?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/tickets`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter["pageSize"] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * MoneysApi - functional programming interface
 * @export
 */
export const MoneysApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = MoneysApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary
     * @param {Array<Ledger>} ledger
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async crupdateLedgers(
      ledger: Array<Ledger>,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Ledger>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.crupdateLedgers(
        ledger,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MoneysApi.crupdateLedgers"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {Array<Operation>} operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async crupdateOperations(
      operation: Array<Operation>,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<Operation>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.crupdateOperations(operation, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MoneysApi.crupdateOperations"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} operationId
     * @param {string} staffId
     * @param {Array<PayedTicket>} payedTicket
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async crupdatePayedTickets(
      operationId: string,
      staffId: string,
      payedTicket: Array<PayedTicket>,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<PayedTicket>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.crupdatePayedTickets(
          operationId,
          staffId,
          payedTicket,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MoneysApi.crupdatePayedTickets"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {Array<CrupdateTicket>} crupdateTicket
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async crupdateTickets(
      crupdateTicket: Array<CrupdateTicket>,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Ticket>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.crupdateTickets(
        crupdateTicket,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MoneysApi.crupdateTickets"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteLedgerById(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ledger>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteLedgerById(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MoneysApi.deleteLedgerById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteOperationById(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Operation>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteOperationById(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MoneysApi.deleteOperationById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteTicketById(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ticket>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteTicketById(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MoneysApi.deleteTicketById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} operationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllOperationStaffs(
      operationId: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAllOperationStaffs(
          operationId,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MoneysApi.getAllOperationStaffs"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} operationId
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllOperationTicketsStatus(
      operationId: string,
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<TicketStatus>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAllOperationTicketsStatus(
          operationId,
          page,
          pageSize,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MoneysApi.getAllOperationTicketsStatus"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLedgerById(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ledger>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLedgerById(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MoneysApi.getLedgerById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {number} [year]
     * @param {GetLedgerStatsTypeEnum} [type]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLedgerStats(
      year?: number,
      type?: GetLedgerStatsTypeEnum,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<LedgerStat>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLedgerStats(
        year,
        type,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MoneysApi.getLedgerStats"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {number} [year]
     * @param {number} [month]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLedgers(
      name?: string,
      year?: number,
      month?: number,
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Ledger>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLedgers(
        name,
        year,
        month,
        page,
        pageSize,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MoneysApi.getLedgers"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOperationById(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Operation>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getOperationById(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MoneysApi.getOperationById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOperationResults(
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<OperationResult>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getOperationResults(
          page,
          pageSize,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MoneysApi.getOperationResults"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} operationId
     * @param {number} ticketNumber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOperationTicketByTicketNumber(
      operationId: string,
      ticketNumber: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayedTicket>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getOperationTicketByTicketNumber(
          operationId,
          ticketNumber,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MoneysApi.getOperationTicketByTicketNumber"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOperations(
      name?: string,
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<Operation>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getOperations(
        name,
        page,
        pageSize,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MoneysApi.getOperations"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} operationId
     * @param {string} staffId
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPayedTickets(
      operationId: string,
      staffId: string,
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<PayedTicket>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPayedTickets(
        operationId,
        staffId,
        page,
        pageSize,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MoneysApi.getPayedTickets"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTicketById(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ticket>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTicketById(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MoneysApi.getTicketById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTickets(
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Ticket>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTickets(
        page,
        pageSize,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MoneysApi.getTickets"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * MoneysApi - factory interface
 * @export
 */
export const MoneysApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = MoneysApiFp(configuration);
  return {
    /**
     *
     * @summary
     * @param {Array<Ledger>} ledger
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateLedgers(
      ledger: Array<Ledger>,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Ledger>> {
      return localVarFp
        .crupdateLedgers(ledger, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {Array<Operation>} operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateOperations(
      operation: Array<Operation>,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Operation>> {
      return localVarFp
        .crupdateOperations(operation, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} operationId
     * @param {string} staffId
     * @param {Array<PayedTicket>} payedTicket
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdatePayedTickets(
      operationId: string,
      staffId: string,
      payedTicket: Array<PayedTicket>,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<PayedTicket>> {
      return localVarFp
        .crupdatePayedTickets(operationId, staffId, payedTicket, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {Array<CrupdateTicket>} crupdateTicket
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateTickets(
      crupdateTicket: Array<CrupdateTicket>,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Ticket>> {
      return localVarFp
        .crupdateTickets(crupdateTicket, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLedgerById(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Ledger> {
      return localVarFp
        .deleteLedgerById(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteOperationById(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Operation> {
      return localVarFp
        .deleteOperationById(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTicketById(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Ticket> {
      return localVarFp
        .deleteTicketById(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} operationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllOperationStaffs(
      operationId: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<User>> {
      return localVarFp
        .getAllOperationStaffs(operationId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} operationId
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllOperationTicketsStatus(
      operationId: string,
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<TicketStatus>> {
      return localVarFp
        .getAllOperationTicketsStatus(operationId, page, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLedgerById(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Ledger> {
      return localVarFp
        .getLedgerById(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {number} [year]
     * @param {GetLedgerStatsTypeEnum} [type]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLedgerStats(
      year?: number,
      type?: GetLedgerStatsTypeEnum,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<LedgerStat>> {
      return localVarFp
        .getLedgerStats(year, type, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {number} [year]
     * @param {number} [month]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLedgers(
      name?: string,
      year?: number,
      month?: number,
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Ledger>> {
      return localVarFp
        .getLedgers(name, year, month, page, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOperationById(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Operation> {
      return localVarFp
        .getOperationById(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOperationResults(
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<OperationResult>> {
      return localVarFp
        .getOperationResults(page, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} operationId
     * @param {number} ticketNumber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOperationTicketByTicketNumber(
      operationId: string,
      ticketNumber: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<PayedTicket> {
      return localVarFp
        .getOperationTicketByTicketNumber(operationId, ticketNumber, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOperations(
      name?: string,
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Operation>> {
      return localVarFp
        .getOperations(name, page, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} operationId
     * @param {string} staffId
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPayedTickets(
      operationId: string,
      staffId: string,
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<PayedTicket>> {
      return localVarFp
        .getPayedTickets(operationId, staffId, page, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTicketById(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Ticket> {
      return localVarFp
        .getTicketById(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTickets(
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Ticket>> {
      return localVarFp
        .getTickets(page, pageSize, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * MoneysApi - object-oriented interface
 * @export
 * @class MoneysApi
 * @extends {BaseAPI}
 */
export class MoneysApi extends BaseAPI {
  /**
   *
   * @summary
   * @param {Array<Ledger>} ledger
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MoneysApi
   */
  public crupdateLedgers(
    ledger: Array<Ledger>,
    options?: RawAxiosRequestConfig
  ) {
    return MoneysApiFp(this.configuration)
      .crupdateLedgers(ledger, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {Array<Operation>} operation
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MoneysApi
   */
  public crupdateOperations(
    operation: Array<Operation>,
    options?: RawAxiosRequestConfig
  ) {
    return MoneysApiFp(this.configuration)
      .crupdateOperations(operation, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} operationId
   * @param {string} staffId
   * @param {Array<PayedTicket>} payedTicket
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MoneysApi
   */
  public crupdatePayedTickets(
    operationId: string,
    staffId: string,
    payedTicket: Array<PayedTicket>,
    options?: RawAxiosRequestConfig
  ) {
    return MoneysApiFp(this.configuration)
      .crupdatePayedTickets(operationId, staffId, payedTicket, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {Array<CrupdateTicket>} crupdateTicket
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MoneysApi
   */
  public crupdateTickets(
    crupdateTicket: Array<CrupdateTicket>,
    options?: RawAxiosRequestConfig
  ) {
    return MoneysApiFp(this.configuration)
      .crupdateTickets(crupdateTicket, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MoneysApi
   */
  public deleteLedgerById(id: string, options?: RawAxiosRequestConfig) {
    return MoneysApiFp(this.configuration)
      .deleteLedgerById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MoneysApi
   */
  public deleteOperationById(id: string, options?: RawAxiosRequestConfig) {
    return MoneysApiFp(this.configuration)
      .deleteOperationById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MoneysApi
   */
  public deleteTicketById(id: string, options?: RawAxiosRequestConfig) {
    return MoneysApiFp(this.configuration)
      .deleteTicketById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} operationId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MoneysApi
   */
  public getAllOperationStaffs(
    operationId: string,
    options?: RawAxiosRequestConfig
  ) {
    return MoneysApiFp(this.configuration)
      .getAllOperationStaffs(operationId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} operationId
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MoneysApi
   */
  public getAllOperationTicketsStatus(
    operationId: string,
    page?: number,
    pageSize?: number,
    options?: RawAxiosRequestConfig
  ) {
    return MoneysApiFp(this.configuration)
      .getAllOperationTicketsStatus(operationId, page, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MoneysApi
   */
  public getLedgerById(id: string, options?: RawAxiosRequestConfig) {
    return MoneysApiFp(this.configuration)
      .getLedgerById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {number} [year]
   * @param {GetLedgerStatsTypeEnum} [type]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MoneysApi
   */
  public getLedgerStats(
    year?: number,
    type?: GetLedgerStatsTypeEnum,
    options?: RawAxiosRequestConfig
  ) {
    return MoneysApiFp(this.configuration)
      .getLedgerStats(year, type, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} [name]
   * @param {number} [year]
   * @param {number} [month]
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MoneysApi
   */
  public getLedgers(
    name?: string,
    year?: number,
    month?: number,
    page?: number,
    pageSize?: number,
    options?: RawAxiosRequestConfig
  ) {
    return MoneysApiFp(this.configuration)
      .getLedgers(name, year, month, page, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MoneysApi
   */
  public getOperationById(id: string, options?: RawAxiosRequestConfig) {
    return MoneysApiFp(this.configuration)
      .getOperationById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MoneysApi
   */
  public getOperationResults(
    page?: number,
    pageSize?: number,
    options?: RawAxiosRequestConfig
  ) {
    return MoneysApiFp(this.configuration)
      .getOperationResults(page, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} operationId
   * @param {number} ticketNumber
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MoneysApi
   */
  public getOperationTicketByTicketNumber(
    operationId: string,
    ticketNumber: number,
    options?: RawAxiosRequestConfig
  ) {
    return MoneysApiFp(this.configuration)
      .getOperationTicketByTicketNumber(operationId, ticketNumber, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} [name]
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MoneysApi
   */
  public getOperations(
    name?: string,
    page?: number,
    pageSize?: number,
    options?: RawAxiosRequestConfig
  ) {
    return MoneysApiFp(this.configuration)
      .getOperations(name, page, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} operationId
   * @param {string} staffId
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MoneysApi
   */
  public getPayedTickets(
    operationId: string,
    staffId: string,
    page?: number,
    pageSize?: number,
    options?: RawAxiosRequestConfig
  ) {
    return MoneysApiFp(this.configuration)
      .getPayedTickets(operationId, staffId, page, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MoneysApi
   */
  public getTicketById(id: string, options?: RawAxiosRequestConfig) {
    return MoneysApiFp(this.configuration)
      .getTicketById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MoneysApi
   */
  public getTickets(
    page?: number,
    pageSize?: number,
    options?: RawAxiosRequestConfig
  ) {
    return MoneysApiFp(this.configuration)
      .getTickets(page, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const GetLedgerStatsTypeEnum = {
  Acculumated: "ACCULUMATED",
  PerYear: "PER_YEAR",
} as const;
export type GetLedgerStatsTypeEnum =
  (typeof GetLedgerStatsTypeEnum)[keyof typeof GetLedgerStatsTypeEnum];

/**
 * ResourcesApi - axios parameter creator
 * @export
 */
export const ResourcesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary
     * @param {Array<Activity>} activity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateActivities: async (
      activity: Array<Activity>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'activity' is not null or undefined
      assertParamExists("crupdateActivities", "activity", activity);
      const localVarPath = `/activities`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        activity,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {Array<Association>} association
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateAssociations: async (
      association: Array<Association>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'association' is not null or undefined
      assertParamExists("crupdateAssociations", "association", association);
      const localVarPath = `/associations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        association,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {Array<Committee>} committee
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateCommittees: async (
      committee: Array<Committee>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'committee' is not null or undefined
      assertParamExists("crupdateCommittees", "committee", committee);
      const localVarPath = `/committees`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        committee,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {Array<Event>} event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateEvents: async (
      event: Array<Event>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'event' is not null or undefined
      assertParamExists("crupdateEvents", "event", event);
      const localVarPath = `/events`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        event,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} activityId
     * @param {Array<CreatePresence>} createPresence
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdatePresences: async (
      activityId: string,
      createPresence: Array<CreatePresence>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'activityId' is not null or undefined
      assertParamExists("crupdatePresences", "activityId", activityId);
      // verify required parameter 'createPresence' is not null or undefined
      assertParamExists("crupdatePresences", "createPresence", createPresence);
      const localVarPath = `/activities/{activityId}/presences`.replace(
        `{${"activityId"}}`,
        encodeURIComponent(String(activityId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createPresence,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {Array<Region>} region
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateRegions: async (
      region: Array<Region>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'region' is not null or undefined
      assertParamExists("crupdateRegions", "region", region);
      const localVarPath = `/regions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        region,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {Array<Responsability>} responsability
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateResponsabilities: async (
      responsability: Array<Responsability>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'responsability' is not null or undefined
      assertParamExists(
        "crupdateResponsabilities",
        "responsability",
        responsability
      );
      const localVarPath = `/responsabilities`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        responsability,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {Array<Sacrament>} sacrament
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateSacraments: async (
      sacrament: Array<Sacrament>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sacrament' is not null or undefined
      assertParamExists("crupdateSacraments", "sacrament", sacrament);
      const localVarPath = `/sacraments`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        sacrament,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteActivityById: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deleteActivityById", "id", id);
      const localVarPath = `/activities/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAssociationById: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deleteAssociationById", "id", id);
      const localVarPath = `/associations/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCommitteeById: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deleteCommitteeById", "id", id);
      const localVarPath = `/committees/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteEventById: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deleteEventById", "id", id);
      const localVarPath = `/events/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRegionById: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deleteRegionById", "id", id);
      const localVarPath = `/regions/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteResponsabilityById: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deleteResponsabilityById", "id", id);
      const localVarPath = `/responsabilities/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSacramentById: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deleteSacramentById", "id", id);
      const localVarPath = `/sacraments/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {string} [afterDate]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActivities: async (
      name?: string,
      afterDate?: string,
      page?: number,
      pageSize?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/activities`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (name !== undefined) {
        localVarQueryParameter["name"] = name;
      }

      if (afterDate !== undefined) {
        localVarQueryParameter["afterDate"] =
          (afterDate as any) instanceof Date
            ? (afterDate as any).toISOString().substring(0, 10)
            : afterDate;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter["pageSize"] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActivityById: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getActivityById", "id", id);
      const localVarPath = `/activities/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAssociationById: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getAssociationById", "id", id);
      const localVarPath = `/associations/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAssociations: async (
      page?: number,
      pageSize?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/associations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter["pageSize"] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCommitteeById: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getCommitteeById", "id", id);
      const localVarPath = `/committees/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCommittees: async (
      name?: string,
      page?: number,
      pageSize?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/committees`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (name !== undefined) {
        localVarQueryParameter["name"] = name;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter["pageSize"] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventById: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getEventById", "id", id);
      const localVarPath = `/events/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {string} [afterDate]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEvents: async (
      name?: string,
      afterDate?: string,
      page?: number,
      pageSize?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/events`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (name !== undefined) {
        localVarQueryParameter["name"] = name;
      }

      if (afterDate !== undefined) {
        localVarQueryParameter["afterDate"] =
          (afterDate as any) instanceof Date
            ? (afterDate as any).toISOString().substring(0, 10)
            : afterDate;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter["pageSize"] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} activityId
     * @param {boolean} [isPresent]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPresencesStatus: async (
      activityId: string,
      isPresent?: boolean,
      page?: number,
      pageSize?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'activityId' is not null or undefined
      assertParamExists("getPresencesStatus", "activityId", activityId);
      const localVarPath = `/activities/{activityId}/status`.replace(
        `{${"activityId"}}`,
        encodeURIComponent(String(activityId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (isPresent !== undefined) {
        localVarQueryParameter["isPresent"] = isPresent;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter["pageSize"] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRegionById: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getRegionById", "id", id);
      const localVarPath = `/regions/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRegions: async (
      name?: string,
      page?: number,
      pageSize?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/regions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (name !== undefined) {
        localVarQueryParameter["name"] = name;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter["pageSize"] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getResponsabilities: async (
      name?: string,
      page?: number,
      pageSize?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/responsabilities`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (name !== undefined) {
        localVarQueryParameter["name"] = name;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter["pageSize"] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getResponsabilityById: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getResponsabilityById", "id", id);
      const localVarPath = `/responsabilities/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSacramentById: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getSacramentById", "id", id);
      const localVarPath = `/sacraments/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSacraments: async (
      name?: string,
      page?: number,
      pageSize?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/sacraments`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (name !== undefined) {
        localVarQueryParameter["name"] = name;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter["pageSize"] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ResourcesApi - functional programming interface
 * @export
 */
export const ResourcesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ResourcesApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary
     * @param {Array<Activity>} activity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async crupdateActivities(
      activity: Array<Activity>,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<Activity>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.crupdateActivities(activity, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResourcesApi.crupdateActivities"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {Array<Association>} association
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async crupdateAssociations(
      association: Array<Association>,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<Association>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.crupdateAssociations(
          association,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResourcesApi.crupdateAssociations"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {Array<Committee>} committee
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async crupdateCommittees(
      committee: Array<Committee>,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<Committee>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.crupdateCommittees(committee, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResourcesApi.crupdateCommittees"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {Array<Event>} event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async crupdateEvents(
      event: Array<Event>,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.crupdateEvents(
        event,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResourcesApi.crupdateEvents"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} activityId
     * @param {Array<CreatePresence>} createPresence
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async crupdatePresences(
      activityId: string,
      createPresence: Array<CreatePresence>,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<Presence>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.crupdatePresences(
          activityId,
          createPresence,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResourcesApi.crupdatePresences"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {Array<Region>} region
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async crupdateRegions(
      region: Array<Region>,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Region>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.crupdateRegions(
        region,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResourcesApi.crupdateRegions"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {Array<Responsability>} responsability
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async crupdateResponsabilities(
      responsability: Array<Responsability>,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<Responsability>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.crupdateResponsabilities(
          responsability,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResourcesApi.crupdateResponsabilities"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {Array<Sacrament>} sacrament
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async crupdateSacraments(
      sacrament: Array<Sacrament>,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<Sacrament>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.crupdateSacraments(sacrament, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResourcesApi.crupdateSacraments"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteActivityById(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Activity>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteActivityById(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResourcesApi.deleteActivityById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteAssociationById(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Association>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteAssociationById(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResourcesApi.deleteAssociationById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteCommitteeById(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Committee>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteCommitteeById(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResourcesApi.deleteCommitteeById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteEventById(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEventById(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResourcesApi.deleteEventById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteRegionById(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Region>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteRegionById(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResourcesApi.deleteRegionById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteResponsabilityById(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Responsability>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteResponsabilityById(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResourcesApi.deleteResponsabilityById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteSacramentById(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sacrament>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteSacramentById(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResourcesApi.deleteSacramentById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {string} [afterDate]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getActivities(
      name?: string,
      afterDate?: string,
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<Activity>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getActivities(
        name,
        afterDate,
        page,
        pageSize,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResourcesApi.getActivities"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getActivityById(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Activity>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getActivityById(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResourcesApi.getActivityById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAssociationById(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Association>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAssociationById(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResourcesApi.getAssociationById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAssociations(
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<Association>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAssociations(
        page,
        pageSize,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResourcesApi.getAssociations"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCommitteeById(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Committee>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCommitteeById(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResourcesApi.getCommitteeById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCommittees(
      name?: string,
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<Committee>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCommittees(
        name,
        page,
        pageSize,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResourcesApi.getCommittees"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEventById(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEventById(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResourcesApi.getEventById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {string} [afterDate]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEvents(
      name?: string,
      afterDate?: string,
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEvents(
        name,
        afterDate,
        page,
        pageSize,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResourcesApi.getEvents"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} activityId
     * @param {boolean} [isPresent]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPresencesStatus(
      activityId: string,
      isPresent?: boolean,
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<PresenceStatus>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getPresencesStatus(
          activityId,
          isPresent,
          page,
          pageSize,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResourcesApi.getPresencesStatus"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRegionById(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Region>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRegionById(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResourcesApi.getRegionById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRegions(
      name?: string,
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Region>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRegions(
        name,
        page,
        pageSize,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResourcesApi.getRegions"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getResponsabilities(
      name?: string,
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<Responsability>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getResponsabilities(
          name,
          page,
          pageSize,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResourcesApi.getResponsabilities"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getResponsabilityById(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Responsability>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getResponsabilityById(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResourcesApi.getResponsabilityById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSacramentById(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sacrament>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getSacramentById(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResourcesApi.getSacramentById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSacraments(
      name?: string,
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<Sacrament>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSacraments(
        name,
        page,
        pageSize,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResourcesApi.getSacraments"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ResourcesApi - factory interface
 * @export
 */
export const ResourcesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ResourcesApiFp(configuration);
  return {
    /**
     *
     * @summary
     * @param {Array<Activity>} activity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateActivities(
      activity: Array<Activity>,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Activity>> {
      return localVarFp
        .crupdateActivities(activity, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {Array<Association>} association
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateAssociations(
      association: Array<Association>,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Association>> {
      return localVarFp
        .crupdateAssociations(association, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {Array<Committee>} committee
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateCommittees(
      committee: Array<Committee>,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Committee>> {
      return localVarFp
        .crupdateCommittees(committee, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {Array<Event>} event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateEvents(
      event: Array<Event>,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Event>> {
      return localVarFp
        .crupdateEvents(event, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} activityId
     * @param {Array<CreatePresence>} createPresence
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdatePresences(
      activityId: string,
      createPresence: Array<CreatePresence>,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Presence>> {
      return localVarFp
        .crupdatePresences(activityId, createPresence, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {Array<Region>} region
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateRegions(
      region: Array<Region>,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Region>> {
      return localVarFp
        .crupdateRegions(region, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {Array<Responsability>} responsability
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateResponsabilities(
      responsability: Array<Responsability>,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Responsability>> {
      return localVarFp
        .crupdateResponsabilities(responsability, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {Array<Sacrament>} sacrament
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateSacraments(
      sacrament: Array<Sacrament>,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Sacrament>> {
      return localVarFp
        .crupdateSacraments(sacrament, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteActivityById(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Activity> {
      return localVarFp
        .deleteActivityById(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAssociationById(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Association> {
      return localVarFp
        .deleteAssociationById(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCommitteeById(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Committee> {
      return localVarFp
        .deleteCommitteeById(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteEventById(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Event> {
      return localVarFp
        .deleteEventById(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRegionById(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Region> {
      return localVarFp
        .deleteRegionById(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteResponsabilityById(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Responsability> {
      return localVarFp
        .deleteResponsabilityById(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSacramentById(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Sacrament> {
      return localVarFp
        .deleteSacramentById(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {string} [afterDate]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActivities(
      name?: string,
      afterDate?: string,
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Activity>> {
      return localVarFp
        .getActivities(name, afterDate, page, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActivityById(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Activity> {
      return localVarFp
        .getActivityById(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAssociationById(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Association> {
      return localVarFp
        .getAssociationById(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAssociations(
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Association>> {
      return localVarFp
        .getAssociations(page, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCommitteeById(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Committee> {
      return localVarFp
        .getCommitteeById(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCommittees(
      name?: string,
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Committee>> {
      return localVarFp
        .getCommittees(name, page, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventById(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Event> {
      return localVarFp
        .getEventById(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {string} [afterDate]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEvents(
      name?: string,
      afterDate?: string,
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Event>> {
      return localVarFp
        .getEvents(name, afterDate, page, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} activityId
     * @param {boolean} [isPresent]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPresencesStatus(
      activityId: string,
      isPresent?: boolean,
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<PresenceStatus>> {
      return localVarFp
        .getPresencesStatus(activityId, isPresent, page, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRegionById(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Region> {
      return localVarFp
        .getRegionById(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRegions(
      name?: string,
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Region>> {
      return localVarFp
        .getRegions(name, page, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getResponsabilities(
      name?: string,
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Responsability>> {
      return localVarFp
        .getResponsabilities(name, page, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getResponsabilityById(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Responsability> {
      return localVarFp
        .getResponsabilityById(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSacramentById(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Sacrament> {
      return localVarFp
        .getSacramentById(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSacraments(
      name?: string,
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Sacrament>> {
      return localVarFp
        .getSacraments(name, page, pageSize, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ResourcesApi - object-oriented interface
 * @export
 * @class ResourcesApi
 * @extends {BaseAPI}
 */
export class ResourcesApi extends BaseAPI {
  /**
   *
   * @summary
   * @param {Array<Activity>} activity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public crupdateActivities(
    activity: Array<Activity>,
    options?: RawAxiosRequestConfig
  ) {
    return ResourcesApiFp(this.configuration)
      .crupdateActivities(activity, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {Array<Association>} association
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public crupdateAssociations(
    association: Array<Association>,
    options?: RawAxiosRequestConfig
  ) {
    return ResourcesApiFp(this.configuration)
      .crupdateAssociations(association, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {Array<Committee>} committee
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public crupdateCommittees(
    committee: Array<Committee>,
    options?: RawAxiosRequestConfig
  ) {
    return ResourcesApiFp(this.configuration)
      .crupdateCommittees(committee, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {Array<Event>} event
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public crupdateEvents(event: Array<Event>, options?: RawAxiosRequestConfig) {
    return ResourcesApiFp(this.configuration)
      .crupdateEvents(event, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} activityId
   * @param {Array<CreatePresence>} createPresence
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public crupdatePresences(
    activityId: string,
    createPresence: Array<CreatePresence>,
    options?: RawAxiosRequestConfig
  ) {
    return ResourcesApiFp(this.configuration)
      .crupdatePresences(activityId, createPresence, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {Array<Region>} region
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public crupdateRegions(
    region: Array<Region>,
    options?: RawAxiosRequestConfig
  ) {
    return ResourcesApiFp(this.configuration)
      .crupdateRegions(region, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {Array<Responsability>} responsability
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public crupdateResponsabilities(
    responsability: Array<Responsability>,
    options?: RawAxiosRequestConfig
  ) {
    return ResourcesApiFp(this.configuration)
      .crupdateResponsabilities(responsability, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {Array<Sacrament>} sacrament
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public crupdateSacraments(
    sacrament: Array<Sacrament>,
    options?: RawAxiosRequestConfig
  ) {
    return ResourcesApiFp(this.configuration)
      .crupdateSacraments(sacrament, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public deleteActivityById(id: string, options?: RawAxiosRequestConfig) {
    return ResourcesApiFp(this.configuration)
      .deleteActivityById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public deleteAssociationById(id: string, options?: RawAxiosRequestConfig) {
    return ResourcesApiFp(this.configuration)
      .deleteAssociationById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public deleteCommitteeById(id: string, options?: RawAxiosRequestConfig) {
    return ResourcesApiFp(this.configuration)
      .deleteCommitteeById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public deleteEventById(id: string, options?: RawAxiosRequestConfig) {
    return ResourcesApiFp(this.configuration)
      .deleteEventById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public deleteRegionById(id: string, options?: RawAxiosRequestConfig) {
    return ResourcesApiFp(this.configuration)
      .deleteRegionById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public deleteResponsabilityById(id: string, options?: RawAxiosRequestConfig) {
    return ResourcesApiFp(this.configuration)
      .deleteResponsabilityById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public deleteSacramentById(id: string, options?: RawAxiosRequestConfig) {
    return ResourcesApiFp(this.configuration)
      .deleteSacramentById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} [name]
   * @param {string} [afterDate]
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public getActivities(
    name?: string,
    afterDate?: string,
    page?: number,
    pageSize?: number,
    options?: RawAxiosRequestConfig
  ) {
    return ResourcesApiFp(this.configuration)
      .getActivities(name, afterDate, page, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public getActivityById(id: string, options?: RawAxiosRequestConfig) {
    return ResourcesApiFp(this.configuration)
      .getActivityById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public getAssociationById(id: string, options?: RawAxiosRequestConfig) {
    return ResourcesApiFp(this.configuration)
      .getAssociationById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public getAssociations(
    page?: number,
    pageSize?: number,
    options?: RawAxiosRequestConfig
  ) {
    return ResourcesApiFp(this.configuration)
      .getAssociations(page, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public getCommitteeById(id: string, options?: RawAxiosRequestConfig) {
    return ResourcesApiFp(this.configuration)
      .getCommitteeById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} [name]
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public getCommittees(
    name?: string,
    page?: number,
    pageSize?: number,
    options?: RawAxiosRequestConfig
  ) {
    return ResourcesApiFp(this.configuration)
      .getCommittees(name, page, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public getEventById(id: string, options?: RawAxiosRequestConfig) {
    return ResourcesApiFp(this.configuration)
      .getEventById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} [name]
   * @param {string} [afterDate]
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public getEvents(
    name?: string,
    afterDate?: string,
    page?: number,
    pageSize?: number,
    options?: RawAxiosRequestConfig
  ) {
    return ResourcesApiFp(this.configuration)
      .getEvents(name, afterDate, page, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} activityId
   * @param {boolean} [isPresent]
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public getPresencesStatus(
    activityId: string,
    isPresent?: boolean,
    page?: number,
    pageSize?: number,
    options?: RawAxiosRequestConfig
  ) {
    return ResourcesApiFp(this.configuration)
      .getPresencesStatus(activityId, isPresent, page, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public getRegionById(id: string, options?: RawAxiosRequestConfig) {
    return ResourcesApiFp(this.configuration)
      .getRegionById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} [name]
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public getRegions(
    name?: string,
    page?: number,
    pageSize?: number,
    options?: RawAxiosRequestConfig
  ) {
    return ResourcesApiFp(this.configuration)
      .getRegions(name, page, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} [name]
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public getResponsabilities(
    name?: string,
    page?: number,
    pageSize?: number,
    options?: RawAxiosRequestConfig
  ) {
    return ResourcesApiFp(this.configuration)
      .getResponsabilities(name, page, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public getResponsabilityById(id: string, options?: RawAxiosRequestConfig) {
    return ResourcesApiFp(this.configuration)
      .getResponsabilityById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public getSacramentById(id: string, options?: RawAxiosRequestConfig) {
    return ResourcesApiFp(this.configuration)
      .getSacramentById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} [name]
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public getSacraments(
    name?: string,
    page?: number,
    pageSize?: number,
    options?: RawAxiosRequestConfig
  ) {
    return ResourcesApiFp(this.configuration)
      .getSacraments(name, page, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SecurityApi - axios parameter creator
 * @export
 */
export const SecurityApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    allowAdminSignup: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/admin-signup/allows`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {SigninPayload} signinPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signin: async (
      signinPayload: SigninPayload,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'signinPayload' is not null or undefined
      assertParamExists("signin", "signinPayload", signinPayload);
      const localVarPath = `/signin`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        signinPayload,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {SigninByRole} signinByRole
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signinByRole: async (
      signinByRole: SigninByRole,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'signinByRole' is not null or undefined
      assertParamExists("signinByRole", "signinByRole", signinByRole);
      const localVarPath = `/signin-by-role`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        signinByRole,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {SignupPayload} signupPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signup: async (
      signupPayload: SignupPayload,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'signupPayload' is not null or undefined
      assertParamExists("signup", "signupPayload", signupPayload);
      const localVarPath = `/signup`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        signupPayload,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Tell who you are
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    whoami: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/whoami`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SecurityApi - functional programming interface
 * @export
 */
export const SecurityApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SecurityApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async allowAdminSignup(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.allowAdminSignup(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SecurityApi.allowAdminSignup"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {SigninPayload} signinPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async signin(
      signinPayload: SigninPayload,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Whoami>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.signin(
        signinPayload,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SecurityApi.signin"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {SigninByRole} signinByRole
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async signinByRole(
      signinByRole: SigninByRole,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Whoami>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.signinByRole(
        signinByRole,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SecurityApi.signinByRole"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {SignupPayload} signupPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async signup(
      signupPayload: SignupPayload,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Whoami>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.signup(
        signupPayload,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SecurityApi.signup"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Tell who you are
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async whoami(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Whoami>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.whoami(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SecurityApi.whoami"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * SecurityApi - factory interface
 * @export
 */
export const SecurityApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = SecurityApiFp(configuration);
  return {
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    allowAdminSignup(options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
      return localVarFp
        .allowAdminSignup(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {SigninPayload} signinPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signin(
      signinPayload: SigninPayload,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Whoami> {
      return localVarFp
        .signin(signinPayload, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {SigninByRole} signinByRole
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signinByRole(
      signinByRole: SigninByRole,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Whoami> {
      return localVarFp
        .signinByRole(signinByRole, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {SignupPayload} signupPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signup(
      signupPayload: SignupPayload,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Whoami> {
      return localVarFp
        .signup(signupPayload, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Tell who you are
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    whoami(options?: RawAxiosRequestConfig): AxiosPromise<Whoami> {
      return localVarFp
        .whoami(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * SecurityApi - object-oriented interface
 * @export
 * @class SecurityApi
 * @extends {BaseAPI}
 */
export class SecurityApi extends BaseAPI {
  /**
   *
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityApi
   */
  public allowAdminSignup(options?: RawAxiosRequestConfig) {
    return SecurityApiFp(this.configuration)
      .allowAdminSignup(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {SigninPayload} signinPayload
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityApi
   */
  public signin(signinPayload: SigninPayload, options?: RawAxiosRequestConfig) {
    return SecurityApiFp(this.configuration)
      .signin(signinPayload, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {SigninByRole} signinByRole
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityApi
   */
  public signinByRole(
    signinByRole: SigninByRole,
    options?: RawAxiosRequestConfig
  ) {
    return SecurityApiFp(this.configuration)
      .signinByRole(signinByRole, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {SignupPayload} signupPayload
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityApi
   */
  public signup(signupPayload: SignupPayload, options?: RawAxiosRequestConfig) {
    return SecurityApiFp(this.configuration)
      .signup(signupPayload, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Tell who you are
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityApi
   */
  public whoami(options?: RawAxiosRequestConfig) {
    return SecurityApiFp(this.configuration)
      .whoami(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary
     * @param {CreateUser} createUser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser: async (
      createUser: CreateUser,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createUser' is not null or undefined
      assertParamExists("createUser", "createUser", createUser);
      const localVarPath = `/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createUser,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserById: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deleteUserById", "id", id);
      const localVarPath = `/users/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {FindDeletedRolesRoleEnum} [role]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findDeletedRoles: async (
      role?: FindDeletedRolesRoleEnum,
      page?: number,
      pageSize?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/deleted-roles`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (role !== undefined) {
        localVarQueryParameter["role"] = role;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter["pageSize"] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserById: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getUserById", "id", id);
      const localVarPath = `/users/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserMemberCount: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/users-member-count`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} [fromDate]
     * @param {string} [endDate]
     * @param {GetUserMembersStatsTypeEnum} [type]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserMembersStats: async (
      fromDate?: string,
      endDate?: string,
      type?: GetUserMembersStatsTypeEnum,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/users/members/stats`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (fromDate !== undefined) {
        localVarQueryParameter["fromDate"] =
          (fromDate as any) instanceof Date
            ? (fromDate as any).toISOString().substring(0, 10)
            : fromDate;
      }

      if (endDate !== undefined) {
        localVarQueryParameter["endDate"] =
          (endDate as any) instanceof Date
            ? (endDate as any).toISOString().substring(0, 10)
            : endDate;
      }

      if (type !== undefined) {
        localVarQueryParameter["type"] = type;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} [q]
     * @param {GetUsersRoleEnum} [role]
     * @param {string} [nic]
     * @param {string} [apv]
     * @param {string} [lastName]
     * @param {string} [firstName]
     * @param {string} [username]
     * @param {string} [responsabilityId]
     * @param {string} [sacramentId]
     * @param {string} [regionId]
     * @param {string} [committeeId]
     * @param {string} [associationId]
     * @param {GetUsersGenderEnum} [gender]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers: async (
      q?: string,
      role?: GetUsersRoleEnum,
      nic?: string,
      apv?: string,
      lastName?: string,
      firstName?: string,
      username?: string,
      responsabilityId?: string,
      sacramentId?: string,
      regionId?: string,
      committeeId?: string,
      associationId?: string,
      gender?: GetUsersGenderEnum,
      page?: number,
      pageSize?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (q !== undefined) {
        localVarQueryParameter["q"] = q;
      }

      if (role !== undefined) {
        localVarQueryParameter["role"] = role;
      }

      if (nic !== undefined) {
        localVarQueryParameter["nic"] = nic;
      }

      if (apv !== undefined) {
        localVarQueryParameter["apv"] = apv;
      }

      if (lastName !== undefined) {
        localVarQueryParameter["lastName"] = lastName;
      }

      if (firstName !== undefined) {
        localVarQueryParameter["firstName"] = firstName;
      }

      if (username !== undefined) {
        localVarQueryParameter["username"] = username;
      }

      if (responsabilityId !== undefined) {
        localVarQueryParameter["responsabilityId"] = responsabilityId;
      }

      if (sacramentId !== undefined) {
        localVarQueryParameter["sacramentId"] = sacramentId;
      }

      if (regionId !== undefined) {
        localVarQueryParameter["regionId"] = regionId;
      }

      if (committeeId !== undefined) {
        localVarQueryParameter["committeeId"] = committeeId;
      }

      if (associationId !== undefined) {
        localVarQueryParameter["associationId"] = associationId;
      }

      if (gender !== undefined) {
        localVarQueryParameter["gender"] = gender;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter["pageSize"] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {File} [file]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProfilePicture: async (
      id: string,
      file?: File,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("updateProfilePicture", "id", id);
      const localVarPath = `/users/{id}/picture/raw`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration &&
        configuration.formDataCtor) ||
        FormData)();

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (file !== undefined) {
        localVarFormParams.append("file", file as any);
      }

      localVarHeaderParameter["Content-Type"] = "multipart/form-data";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {UpdateUser} updateUser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserInfo: async (
      id: string,
      updateUser: UpdateUser,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("updateUserInfo", "id", id);
      // verify required parameter 'updateUser' is not null or undefined
      assertParamExists("updateUserInfo", "updateUser", updateUser);
      const localVarPath = `/users/{id}/infos`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateUser,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary
     * @param {CreateUser} createUser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createUser(
      createUser: CreateUser,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(
        createUser,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UsersApi.createUser"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteUserById(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserById(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UsersApi.deleteUserById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {FindDeletedRolesRoleEnum} [role]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async findDeletedRoles(
      role?: FindDeletedRolesRoleEnum,
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<DeletedRole>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.findDeletedRoles(
          role,
          page,
          pageSize,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UsersApi.findDeletedRoles"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserById(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUserById(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UsersApi.getUserById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserMemberCount(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Count>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUserMemberCount(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UsersApi.getUserMemberCount"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} [fromDate]
     * @param {string} [endDate]
     * @param {GetUserMembersStatsTypeEnum} [type]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserMembersStats(
      fromDate?: string,
      endDate?: string,
      type?: GetUserMembersStatsTypeEnum,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<UserStat>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUserMembersStats(
          fromDate,
          endDate,
          type,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UsersApi.getUserMembersStats"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} [q]
     * @param {GetUsersRoleEnum} [role]
     * @param {string} [nic]
     * @param {string} [apv]
     * @param {string} [lastName]
     * @param {string} [firstName]
     * @param {string} [username]
     * @param {string} [responsabilityId]
     * @param {string} [sacramentId]
     * @param {string} [regionId]
     * @param {string} [committeeId]
     * @param {string} [associationId]
     * @param {GetUsersGenderEnum} [gender]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUsers(
      q?: string,
      role?: GetUsersRoleEnum,
      nic?: string,
      apv?: string,
      lastName?: string,
      firstName?: string,
      username?: string,
      responsabilityId?: string,
      sacramentId?: string,
      regionId?: string,
      committeeId?: string,
      associationId?: string,
      gender?: GetUsersGenderEnum,
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(
        q,
        role,
        nic,
        apv,
        lastName,
        firstName,
        username,
        responsabilityId,
        sacramentId,
        regionId,
        committeeId,
        associationId,
        gender,
        page,
        pageSize,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UsersApi.getUsers"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {File} [file]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateProfilePicture(
      id: string,
      file?: File,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UploadeSuccessResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateProfilePicture(id, file, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UsersApi.updateProfilePicture"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {UpdateUser} updateUser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateUserInfo(
      id: string,
      updateUser: UpdateUser,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserInfo(
        id,
        updateUser,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UsersApi.updateUserInfo"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = UsersApiFp(configuration);
  return {
    /**
     *
     * @summary
     * @param {CreateUser} createUser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser(
      createUser: CreateUser,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<User> {
      return localVarFp
        .createUser(createUser, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserById(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<User> {
      return localVarFp
        .deleteUserById(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {FindDeletedRolesRoleEnum} [role]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findDeletedRoles(
      role?: FindDeletedRolesRoleEnum,
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<DeletedRole>> {
      return localVarFp
        .findDeletedRoles(role, page, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserById(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<User> {
      return localVarFp
        .getUserById(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserMemberCount(options?: RawAxiosRequestConfig): AxiosPromise<Count> {
      return localVarFp
        .getUserMemberCount(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} [fromDate]
     * @param {string} [endDate]
     * @param {GetUserMembersStatsTypeEnum} [type]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserMembersStats(
      fromDate?: string,
      endDate?: string,
      type?: GetUserMembersStatsTypeEnum,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<UserStat>> {
      return localVarFp
        .getUserMembersStats(fromDate, endDate, type, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} [q]
     * @param {GetUsersRoleEnum} [role]
     * @param {string} [nic]
     * @param {string} [apv]
     * @param {string} [lastName]
     * @param {string} [firstName]
     * @param {string} [username]
     * @param {string} [responsabilityId]
     * @param {string} [sacramentId]
     * @param {string} [regionId]
     * @param {string} [committeeId]
     * @param {string} [associationId]
     * @param {GetUsersGenderEnum} [gender]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers(
      q?: string,
      role?: GetUsersRoleEnum,
      nic?: string,
      apv?: string,
      lastName?: string,
      firstName?: string,
      username?: string,
      responsabilityId?: string,
      sacramentId?: string,
      regionId?: string,
      committeeId?: string,
      associationId?: string,
      gender?: GetUsersGenderEnum,
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<User>> {
      return localVarFp
        .getUsers(
          q,
          role,
          nic,
          apv,
          lastName,
          firstName,
          username,
          responsabilityId,
          sacramentId,
          regionId,
          committeeId,
          associationId,
          gender,
          page,
          pageSize,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {File} [file]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProfilePicture(
      id: string,
      file?: File,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UploadeSuccessResponse> {
      return localVarFp
        .updateProfilePicture(id, file, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {UpdateUser} updateUser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserInfo(
      id: string,
      updateUser: UpdateUser,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<User> {
      return localVarFp
        .updateUserInfo(id, updateUser, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
  /**
   *
   * @summary
   * @param {CreateUser} createUser
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public createUser(createUser: CreateUser, options?: RawAxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .createUser(createUser, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public deleteUserById(id: string, options?: RawAxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .deleteUserById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {FindDeletedRolesRoleEnum} [role]
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public findDeletedRoles(
    role?: FindDeletedRolesRoleEnum,
    page?: number,
    pageSize?: number,
    options?: RawAxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .findDeletedRoles(role, page, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getUserById(id: string, options?: RawAxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .getUserById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getUserMemberCount(options?: RawAxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .getUserMemberCount(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} [fromDate]
   * @param {string} [endDate]
   * @param {GetUserMembersStatsTypeEnum} [type]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getUserMembersStats(
    fromDate?: string,
    endDate?: string,
    type?: GetUserMembersStatsTypeEnum,
    options?: RawAxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .getUserMembersStats(fromDate, endDate, type, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} [q]
   * @param {GetUsersRoleEnum} [role]
   * @param {string} [nic]
   * @param {string} [apv]
   * @param {string} [lastName]
   * @param {string} [firstName]
   * @param {string} [username]
   * @param {string} [responsabilityId]
   * @param {string} [sacramentId]
   * @param {string} [regionId]
   * @param {string} [committeeId]
   * @param {string} [associationId]
   * @param {GetUsersGenderEnum} [gender]
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getUsers(
    q?: string,
    role?: GetUsersRoleEnum,
    nic?: string,
    apv?: string,
    lastName?: string,
    firstName?: string,
    username?: string,
    responsabilityId?: string,
    sacramentId?: string,
    regionId?: string,
    committeeId?: string,
    associationId?: string,
    gender?: GetUsersGenderEnum,
    page?: number,
    pageSize?: number,
    options?: RawAxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .getUsers(
        q,
        role,
        nic,
        apv,
        lastName,
        firstName,
        username,
        responsabilityId,
        sacramentId,
        regionId,
        committeeId,
        associationId,
        gender,
        page,
        pageSize,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {File} [file]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public updateProfilePicture(
    id: string,
    file?: File,
    options?: RawAxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .updateProfilePicture(id, file, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {UpdateUser} updateUser
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public updateUserInfo(
    id: string,
    updateUser: UpdateUser,
    options?: RawAxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .updateUserInfo(id, updateUser, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const FindDeletedRolesRoleEnum = {
  Admin: "ADMIN",
  RegionManager: "REGION_MANAGER",
  CommitteeManager: "COMMITTEE_MANAGER",
  AssociationManager: "ASSOCIATION_MANAGER",
  SimpleUser: "SIMPLE_USER",
} as const;
export type FindDeletedRolesRoleEnum =
  (typeof FindDeletedRolesRoleEnum)[keyof typeof FindDeletedRolesRoleEnum];
/**
 * @export
 */
export const GetUserMembersStatsTypeEnum = {
  Acculumated: "ACCULUMATED",
  PerYear: "PER_YEAR",
} as const;
export type GetUserMembersStatsTypeEnum =
  (typeof GetUserMembersStatsTypeEnum)[keyof typeof GetUserMembersStatsTypeEnum];
/**
 * @export
 */
export const GetUsersRoleEnum = {
  Admin: "ADMIN",
  RegionManager: "REGION_MANAGER",
  CommitteeManager: "COMMITTEE_MANAGER",
  AssociationManager: "ASSOCIATION_MANAGER",
  SimpleUser: "SIMPLE_USER",
} as const;
export type GetUsersRoleEnum =
  (typeof GetUsersRoleEnum)[keyof typeof GetUsersRoleEnum];
/**
 * @export
 */
export const GetUsersGenderEnum = {
  Male: "MALE",
  Female: "FEMALE",
} as const;
export type GetUsersGenderEnum =
  (typeof GetUsersGenderEnum)[keyof typeof GetUsersGenderEnum];
