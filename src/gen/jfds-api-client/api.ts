/* tslint:disable */
/* eslint-disable */
/**
 * Jfds Api
 * Jfds
 *
 * The version of the OpenAPI document: 0.0.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from "./configuration";
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from "axios";
import globalAxios from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "./common";
import type { RequestArgs } from "./base";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  BaseAPI,
  RequiredError,
  operationServerMap,
} from "./base";

/**
 *
 * @export
 * @interface ApiResponseError
 */
export interface ApiResponseError {
  /**
   *
   * @type {number}
   * @memberof ApiResponseError
   */
  statusCode: number;
  /**
   *
   * @type {string}
   * @memberof ApiResponseError
   */
  message: string;
  /**
   *
   * @type {string}
   * @memberof ApiResponseError
   */
  error: string;
}
/**
 *
 * @export
 * @interface Association
 */
export interface Association {
  /**
   *
   * @type {string}
   * @memberof Association
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Association
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof Association
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof Association
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof Association
   */
  updatedAt: string;
}
/**
 *
 * @export
 * @interface Committee
 */
export interface Committee {
  /**
   *
   * @type {string}
   * @memberof Committee
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Committee
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof Committee
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof Committee
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof Committee
   */
  updatedAt: string;
}
/**
 *
 * @export
 * @interface CrupdateTicket
 */
export interface CrupdateTicket {
  /**
   *
   * @type {string}
   * @memberof CrupdateTicket
   */
  id: string;
  /**
   *
   * @type {number}
   * @memberof CrupdateTicket
   */
  fromNumber: number;
  /**
   *
   * @type {number}
   * @memberof CrupdateTicket
   */
  toNumber: number;
  /**
   *
   * @type {string}
   * @memberof CrupdateTicket
   */
  operationId: string;
  /**
   *
   * @type {string}
   * @memberof CrupdateTicket
   */
  staffId: string;
  /**
   *
   * @type {string}
   * @memberof CrupdateTicket
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof CrupdateTicket
   */
  updatedAt: string;
}
/**
 *
 * @export
 * @interface Dummy
 */
export interface Dummy {
  /**
   *
   * @type {string}
   * @memberof Dummy
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Dummy
   */
  name: string;
}
/**
 *
 * @export
 * @interface Event
 */
export interface Event {
  /**
   *
   * @type {string}
   * @memberof Event
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Event
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof Event
   */
  place: string;
  /**
   *
   * @type {string}
   * @memberof Event
   */
  beginDate: string;
  /**
   *
   * @type {string}
   * @memberof Event
   */
  endDate: string;
  /**
   *
   * @type {string}
   * @memberof Event
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof Event
   */
  updatedAt: string;
}
/**
 *
 * @export
 * @interface Ledger
 */
export interface Ledger {
  /**
   *
   * @type {string}
   * @memberof Ledger
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Ledger
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof Ledger
   */
  ledgerDate: string;
  /**
   *
   * @type {string}
   * @memberof Ledger
   */
  mouvementType: LedgerMouvementTypeEnum;
  /**
   *
   * @type {string}
   * @memberof Ledger
   */
  price: string;
  /**
   *
   * @type {string}
   * @memberof Ledger
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof Ledger
   */
  updatedAt: string;
}

export const LedgerMouvementTypeEnum = {
  In: "IN",
  Out: "OUT",
} as const;

export type LedgerMouvementTypeEnum =
  (typeof LedgerMouvementTypeEnum)[keyof typeof LedgerMouvementTypeEnum];

/**
 *
 * @export
 * @interface Operation
 */
export interface Operation {
  /**
   *
   * @type {string}
   * @memberof Operation
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Operation
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof Operation
   */
  numberOfTickets: number;
  /**
   *
   * @type {string}
   * @memberof Operation
   */
  ticketPrice: string;
  /**
   *
   * @type {string}
   * @memberof Operation
   */
  description: string;
  /**
   *
   * @type {string}
   * @memberof Operation
   */
  operationDate: string;
  /**
   *
   * @type {string}
   * @memberof Operation
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof Operation
   */
  updatedAt: string;
}
/**
 *
 * @export
 * @interface OperationResult
 */
export interface OperationResult {
  /**
   *
   * @type {Operation}
   * @memberof OperationResult
   */
  operation: Operation;
  /**
   *
   * @type {number}
   * @memberof OperationResult
   */
  numberOfDistributed: number;
  /**
   *
   * @type {string}
   * @memberof OperationResult
   */
  sumOfDistributed: string;
}
/**
 *
 * @export
 * @interface PayedTicket
 */
export interface PayedTicket {
  /**
   *
   * @type {string}
   * @memberof PayedTicket
   */
  id: string;
  /**
   *
   * @type {number}
   * @memberof PayedTicket
   */
  ticketNumber: number;
  /**
   *
   * @type {string}
   * @memberof PayedTicket
   */
  ticketId: string;
  /**
   *
   * @type {boolean}
   * @memberof PayedTicket
   */
  isPayed: boolean;
  /**
   *
   * @type {boolean}
   * @memberof PayedTicket
   */
  isDistributed: boolean;
  /**
   *
   * @type {string}
   * @memberof PayedTicket
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof PayedTicket
   */
  updatedAt: string;
}
/**
 *
 * @export
 * @interface Region
 */
export interface Region {
  /**
   *
   * @type {string}
   * @memberof Region
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Region
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof Region
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof Region
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof Region
   */
  updatedAt: string;
}
/**
 *
 * @export
 * @interface Responsability
 */
export interface Responsability {
  /**
   *
   * @type {string}
   * @memberof Responsability
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Responsability
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof Responsability
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof Responsability
   */
  updatedAt: string;
}
/**
 *
 * @export
 * @interface Role
 */
export interface Role {
  /**
   *
   * @type {string}
   * @memberof Role
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Role
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof Role
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof Role
   */
  updatedAt: string;
}
/**
 *
 * @export
 * @interface Sacrament
 */
export interface Sacrament {
  /**
   *
   * @type {string}
   * @memberof Sacrament
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Sacrament
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof Sacrament
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof Sacrament
   */
  updatedAt: string;
}
/**
 *
 * @export
 * @interface SigninPayload
 */
export interface SigninPayload {
  /**
   *
   * @type {string}
   * @memberof SigninPayload
   */
  password: string;
  /**
   *
   * @type {string}
   * @memberof SigninPayload
   */
  username: string;
}
/**
 *
 * @export
 * @interface SignupPayload
 */
export interface SignupPayload {
  /**
   *
   * @type {string}
   * @memberof SignupPayload
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof SignupPayload
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof SignupPayload
   */
  username: string;
  /**
   *
   * @type {string}
   * @memberof SignupPayload
   */
  firstName: string;
  /**
   *
   * @type {string}
   * @memberof SignupPayload
   */
  lastName: string;
  /**
   *
   * @type {string}
   * @memberof SignupPayload
   */
  nic?: string;
  /**
   *
   * @type {string}
   * @memberof SignupPayload
   */
  photo?: string;
  /**
   *
   * @type {string}
   * @memberof SignupPayload
   */
  birthDate: string;
  /**
   *
   * @type {string}
   * @memberof SignupPayload
   */
  address: string;
  /**
   *
   * @type {string}
   * @memberof SignupPayload
   */
  gender: SignupPayloadGenderEnum;
  /**
   *
   * @type {string}
   * @memberof SignupPayload
   */
  apv?: string;
  /**
   *
   * @type {string}
   * @memberof SignupPayload
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof SignupPayload
   */
  updatedAt: string;
  /**
   *
   * @type {string}
   * @memberof SignupPayload
   */
  roleId: string;
  /**
   *
   * @type {string}
   * @memberof SignupPayload
   */
  password: string;
}

export const SignupPayloadGenderEnum = {
  Male: "MALE",
  Female: "FEMALE",
} as const;

export type SignupPayloadGenderEnum =
  (typeof SignupPayloadGenderEnum)[keyof typeof SignupPayloadGenderEnum];

/**
 *
 * @export
 * @interface Ticket
 */
export interface Ticket {
  /**
   *
   * @type {string}
   * @memberof Ticket
   */
  id: string;
  /**
   *
   * @type {number}
   * @memberof Ticket
   */
  fromNumber: number;
  /**
   *
   * @type {number}
   * @memberof Ticket
   */
  toNumber: number;
  /**
   *
   * @type {Operation}
   * @memberof Ticket
   */
  operation: Operation;
  /**
   *
   * @type {User}
   * @memberof Ticket
   */
  staff: User;
  /**
   *
   * @type {string}
   * @memberof Ticket
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof Ticket
   */
  updatedAt: string;
}
/**
 *
 * @export
 * @interface TicketStatus
 */
export interface TicketStatus {
  /**
   *
   * @type {Ticket}
   * @memberof TicketStatus
   */
  ticket: Ticket;
  /**
   *
   * @type {number}
   * @memberof TicketStatus
   */
  numberOfTickets: number;
  /**
   *
   * @type {number}
   * @memberof TicketStatus
   */
  numberOfPayedTickets: number;
  /**
   *
   * @type {number}
   * @memberof TicketStatus
   */
  numberOfNotPayedTickets: number;
  /**
   *
   * @type {number}
   * @memberof TicketStatus
   */
  pourcentageOfPayedTickets: number;
  /**
   *
   * @type {number}
   * @memberof TicketStatus
   */
  pourcentageOfNotPayedTickets: number;
  /**
   *
   * @type {string}
   * @memberof TicketStatus
   */
  notPayedAmount: string;
  /**
   *
   * @type {string}
   * @memberof TicketStatus
   */
  payedAmount: string;
}
/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {string}
   * @memberof User
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  username: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  firstName: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  lastName: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  nic?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  photo?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  birthDate: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  address: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  gender: UserGenderEnum;
  /**
   *
   * @type {string}
   * @memberof User
   */
  apv?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  updatedAt: string;
  /**
   *
   * @type {Role}
   * @memberof User
   */
  role: Role;
}

export const UserGenderEnum = {
  Male: "MALE",
  Female: "FEMALE",
} as const;

export type UserGenderEnum =
  (typeof UserGenderEnum)[keyof typeof UserGenderEnum];

/**
 *
 * @export
 * @interface Whoami
 */
export interface Whoami {
  /**
   *
   * @type {string}
   * @memberof Whoami
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Whoami
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof Whoami
   */
  username: string;
  /**
   *
   * @type {string}
   * @memberof Whoami
   */
  firstName: string;
  /**
   *
   * @type {string}
   * @memberof Whoami
   */
  lastName: string;
  /**
   *
   * @type {string}
   * @memberof Whoami
   */
  nic?: string;
  /**
   *
   * @type {string}
   * @memberof Whoami
   */
  photo?: string;
  /**
   *
   * @type {string}
   * @memberof Whoami
   */
  birthDate: string;
  /**
   *
   * @type {string}
   * @memberof Whoami
   */
  address: string;
  /**
   *
   * @type {string}
   * @memberof Whoami
   */
  gender: WhoamiGenderEnum;
  /**
   *
   * @type {string}
   * @memberof Whoami
   */
  apv?: string;
  /**
   *
   * @type {string}
   * @memberof Whoami
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof Whoami
   */
  updatedAt: string;
  /**
   *
   * @type {Role}
   * @memberof Whoami
   */
  role: Role;
  /**
   *
   * @type {string}
   * @memberof Whoami
   */
  token: string;
}

export const WhoamiGenderEnum = {
  Male: "MALE",
  Female: "FEMALE",
} as const;

export type WhoamiGenderEnum =
  (typeof WhoamiGenderEnum)[keyof typeof WhoamiGenderEnum];

/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDummies: async (
      page?: number,
      pageSize?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/dummies`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter["pageSize"] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPrivateDummies: async (
      page?: number,
      pageSize?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/dummies/private`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter["pageSize"] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ping: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ping`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDummies(
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Dummy>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDummies(
        page,
        pageSize,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["HealthApi.getDummies"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPrivateDummies(
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Dummy>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getPrivateDummies(
          page,
          pageSize,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["HealthApi.getPrivateDummies"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ping(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.ping(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["HealthApi.ping"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = HealthApiFp(configuration);
  return {
    /**
     *
     * @summary
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDummies(
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Dummy>> {
      return localVarFp
        .getDummies(page, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPrivateDummies(
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Dummy>> {
      return localVarFp
        .getPrivateDummies(page, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ping(options?: RawAxiosRequestConfig): AxiosPromise<string> {
      return localVarFp
        .ping(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
  /**
   *
   * @summary
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HealthApi
   */
  public getDummies(
    page?: number,
    pageSize?: number,
    options?: RawAxiosRequestConfig
  ) {
    return HealthApiFp(this.configuration)
      .getDummies(page, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HealthApi
   */
  public getPrivateDummies(
    page?: number,
    pageSize?: number,
    options?: RawAxiosRequestConfig
  ) {
    return HealthApiFp(this.configuration)
      .getPrivateDummies(page, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HealthApi
   */
  public ping(options?: RawAxiosRequestConfig) {
    return HealthApiFp(this.configuration)
      .ping(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * MoneysApi - axios parameter creator
 * @export
 */
export const MoneysApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary
     * @param {Array<Ledger>} ledger
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateLedgers: async (
      ledger: Array<Ledger>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'ledger' is not null or undefined
      assertParamExists("crupdateLedgers", "ledger", ledger);
      const localVarPath = `/ledgers`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        ledger,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {Array<Operation>} operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateOperations: async (
      operation: Array<Operation>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'operation' is not null or undefined
      assertParamExists("crupdateOperations", "operation", operation);
      const localVarPath = `/operations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        operation,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} operationId
     * @param {string} staffId
     * @param {Array<PayedTicket>} payedTicket
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdatePayedTickets: async (
      operationId: string,
      staffId: string,
      payedTicket: Array<PayedTicket>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'operationId' is not null or undefined
      assertParamExists("crupdatePayedTickets", "operationId", operationId);
      // verify required parameter 'staffId' is not null or undefined
      assertParamExists("crupdatePayedTickets", "staffId", staffId);
      // verify required parameter 'payedTicket' is not null or undefined
      assertParamExists("crupdatePayedTickets", "payedTicket", payedTicket);
      const localVarPath =
        `/operation/{operationId}/staffs/{staffId}/payed-tickets`
          .replace(
            `{${"operationId"}}`,
            encodeURIComponent(String(operationId))
          )
          .replace(`{${"staffId"}}`, encodeURIComponent(String(staffId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        payedTicket,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {Array<CrupdateTicket>} crupdateTicket
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateTickets: async (
      crupdateTicket: Array<CrupdateTicket>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'crupdateTicket' is not null or undefined
      assertParamExists("crupdateTickets", "crupdateTicket", crupdateTicket);
      const localVarPath = `/tickets`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        crupdateTicket,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLedgerById: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deleteLedgerById", "id", id);
      const localVarPath = `/ledgers/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteOperationById: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deleteOperationById", "id", id);
      const localVarPath = `/operations/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTicketById: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deleteTicketById", "id", id);
      const localVarPath = `/tickets/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} operationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllOperationStaffs: async (
      operationId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'operationId' is not null or undefined
      assertParamExists("getAllOperationStaffs", "operationId", operationId);
      const localVarPath = `/operations/{operationId}/staffs`.replace(
        `{${"operationId"}}`,
        encodeURIComponent(String(operationId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} operationId
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllOperationTicketsStatus: async (
      operationId: string,
      page?: number,
      pageSize?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'operationId' is not null or undefined
      assertParamExists(
        "getAllOperationTicketsStatus",
        "operationId",
        operationId
      );
      const localVarPath = `/operations/{operationId}/tickets/status`.replace(
        `{${"operationId"}}`,
        encodeURIComponent(String(operationId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter["pageSize"] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLedgerById: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getLedgerById", "id", id);
      const localVarPath = `/ledgers/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLedgers: async (
      name?: string,
      page?: number,
      pageSize?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/ledgers`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (name !== undefined) {
        localVarQueryParameter["name"] = name;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter["pageSize"] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOperationById: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getOperationById", "id", id);
      const localVarPath = `/operations/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOperationResults: async (
      page?: number,
      pageSize?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/operations/results/all`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter["pageSize"] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} operationId
     * @param {number} ticketNumber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOperationTicketByTicketNumber: async (
      operationId: string,
      ticketNumber: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'operationId' is not null or undefined
      assertParamExists(
        "getOperationTicketByTicketNumber",
        "operationId",
        operationId
      );
      // verify required parameter 'ticketNumber' is not null or undefined
      assertParamExists(
        "getOperationTicketByTicketNumber",
        "ticketNumber",
        ticketNumber
      );
      const localVarPath = `/operation/{operationId}/tickets/{ticketNumber}`
        .replace(`{${"operationId"}}`, encodeURIComponent(String(operationId)))
        .replace(
          `{${"ticketNumber"}}`,
          encodeURIComponent(String(ticketNumber))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOperations: async (
      name?: string,
      page?: number,
      pageSize?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/operations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (name !== undefined) {
        localVarQueryParameter["name"] = name;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter["pageSize"] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} operationId
     * @param {string} staffId
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPayedTickets: async (
      operationId: string,
      staffId: string,
      page?: number,
      pageSize?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'operationId' is not null or undefined
      assertParamExists("getPayedTickets", "operationId", operationId);
      // verify required parameter 'staffId' is not null or undefined
      assertParamExists("getPayedTickets", "staffId", staffId);
      const localVarPath =
        `/operation/{operationId}/staffs/{staffId}/payed-tickets`
          .replace(
            `{${"operationId"}}`,
            encodeURIComponent(String(operationId))
          )
          .replace(`{${"staffId"}}`, encodeURIComponent(String(staffId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter["pageSize"] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTicketById: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getTicketById", "id", id);
      const localVarPath = `/tickets/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTickets: async (
      page?: number,
      pageSize?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/tickets`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter["pageSize"] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * MoneysApi - functional programming interface
 * @export
 */
export const MoneysApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = MoneysApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary
     * @param {Array<Ledger>} ledger
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async crupdateLedgers(
      ledger: Array<Ledger>,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Ledger>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.crupdateLedgers(
        ledger,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MoneysApi.crupdateLedgers"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {Array<Operation>} operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async crupdateOperations(
      operation: Array<Operation>,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<Operation>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.crupdateOperations(operation, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MoneysApi.crupdateOperations"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} operationId
     * @param {string} staffId
     * @param {Array<PayedTicket>} payedTicket
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async crupdatePayedTickets(
      operationId: string,
      staffId: string,
      payedTicket: Array<PayedTicket>,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<PayedTicket>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.crupdatePayedTickets(
          operationId,
          staffId,
          payedTicket,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MoneysApi.crupdatePayedTickets"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {Array<CrupdateTicket>} crupdateTicket
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async crupdateTickets(
      crupdateTicket: Array<CrupdateTicket>,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Ticket>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.crupdateTickets(
        crupdateTicket,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MoneysApi.crupdateTickets"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteLedgerById(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ledger>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteLedgerById(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MoneysApi.deleteLedgerById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteOperationById(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Operation>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteOperationById(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MoneysApi.deleteOperationById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteTicketById(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ticket>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteTicketById(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MoneysApi.deleteTicketById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} operationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllOperationStaffs(
      operationId: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAllOperationStaffs(
          operationId,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MoneysApi.getAllOperationStaffs"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} operationId
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllOperationTicketsStatus(
      operationId: string,
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<TicketStatus>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAllOperationTicketsStatus(
          operationId,
          page,
          pageSize,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MoneysApi.getAllOperationTicketsStatus"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLedgerById(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ledger>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLedgerById(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MoneysApi.getLedgerById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLedgers(
      name?: string,
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Ledger>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLedgers(
        name,
        page,
        pageSize,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MoneysApi.getLedgers"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOperationById(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Operation>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getOperationById(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MoneysApi.getOperationById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOperationResults(
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<OperationResult>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getOperationResults(
          page,
          pageSize,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MoneysApi.getOperationResults"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} operationId
     * @param {number} ticketNumber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOperationTicketByTicketNumber(
      operationId: string,
      ticketNumber: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayedTicket>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getOperationTicketByTicketNumber(
          operationId,
          ticketNumber,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MoneysApi.getOperationTicketByTicketNumber"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOperations(
      name?: string,
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<Operation>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getOperations(
        name,
        page,
        pageSize,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MoneysApi.getOperations"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} operationId
     * @param {string} staffId
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPayedTickets(
      operationId: string,
      staffId: string,
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<PayedTicket>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPayedTickets(
        operationId,
        staffId,
        page,
        pageSize,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MoneysApi.getPayedTickets"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTicketById(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ticket>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTicketById(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MoneysApi.getTicketById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTickets(
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Ticket>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTickets(
        page,
        pageSize,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MoneysApi.getTickets"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * MoneysApi - factory interface
 * @export
 */
export const MoneysApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = MoneysApiFp(configuration);
  return {
    /**
     *
     * @summary
     * @param {Array<Ledger>} ledger
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateLedgers(
      ledger: Array<Ledger>,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Ledger>> {
      return localVarFp
        .crupdateLedgers(ledger, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {Array<Operation>} operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateOperations(
      operation: Array<Operation>,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Operation>> {
      return localVarFp
        .crupdateOperations(operation, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} operationId
     * @param {string} staffId
     * @param {Array<PayedTicket>} payedTicket
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdatePayedTickets(
      operationId: string,
      staffId: string,
      payedTicket: Array<PayedTicket>,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<PayedTicket>> {
      return localVarFp
        .crupdatePayedTickets(operationId, staffId, payedTicket, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {Array<CrupdateTicket>} crupdateTicket
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateTickets(
      crupdateTicket: Array<CrupdateTicket>,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Ticket>> {
      return localVarFp
        .crupdateTickets(crupdateTicket, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLedgerById(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Ledger> {
      return localVarFp
        .deleteLedgerById(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteOperationById(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Operation> {
      return localVarFp
        .deleteOperationById(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTicketById(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Ticket> {
      return localVarFp
        .deleteTicketById(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} operationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllOperationStaffs(
      operationId: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<User>> {
      return localVarFp
        .getAllOperationStaffs(operationId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} operationId
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllOperationTicketsStatus(
      operationId: string,
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<TicketStatus>> {
      return localVarFp
        .getAllOperationTicketsStatus(operationId, page, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLedgerById(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Ledger> {
      return localVarFp
        .getLedgerById(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLedgers(
      name?: string,
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Ledger>> {
      return localVarFp
        .getLedgers(name, page, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOperationById(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Operation> {
      return localVarFp
        .getOperationById(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOperationResults(
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<OperationResult>> {
      return localVarFp
        .getOperationResults(page, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} operationId
     * @param {number} ticketNumber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOperationTicketByTicketNumber(
      operationId: string,
      ticketNumber: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<PayedTicket> {
      return localVarFp
        .getOperationTicketByTicketNumber(operationId, ticketNumber, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOperations(
      name?: string,
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Operation>> {
      return localVarFp
        .getOperations(name, page, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} operationId
     * @param {string} staffId
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPayedTickets(
      operationId: string,
      staffId: string,
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<PayedTicket>> {
      return localVarFp
        .getPayedTickets(operationId, staffId, page, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTicketById(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Ticket> {
      return localVarFp
        .getTicketById(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTickets(
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Ticket>> {
      return localVarFp
        .getTickets(page, pageSize, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * MoneysApi - object-oriented interface
 * @export
 * @class MoneysApi
 * @extends {BaseAPI}
 */
export class MoneysApi extends BaseAPI {
  /**
   *
   * @summary
   * @param {Array<Ledger>} ledger
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MoneysApi
   */
  public crupdateLedgers(
    ledger: Array<Ledger>,
    options?: RawAxiosRequestConfig
  ) {
    return MoneysApiFp(this.configuration)
      .crupdateLedgers(ledger, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {Array<Operation>} operation
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MoneysApi
   */
  public crupdateOperations(
    operation: Array<Operation>,
    options?: RawAxiosRequestConfig
  ) {
    return MoneysApiFp(this.configuration)
      .crupdateOperations(operation, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} operationId
   * @param {string} staffId
   * @param {Array<PayedTicket>} payedTicket
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MoneysApi
   */
  public crupdatePayedTickets(
    operationId: string,
    staffId: string,
    payedTicket: Array<PayedTicket>,
    options?: RawAxiosRequestConfig
  ) {
    return MoneysApiFp(this.configuration)
      .crupdatePayedTickets(operationId, staffId, payedTicket, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {Array<CrupdateTicket>} crupdateTicket
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MoneysApi
   */
  public crupdateTickets(
    crupdateTicket: Array<CrupdateTicket>,
    options?: RawAxiosRequestConfig
  ) {
    return MoneysApiFp(this.configuration)
      .crupdateTickets(crupdateTicket, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MoneysApi
   */
  public deleteLedgerById(id: string, options?: RawAxiosRequestConfig) {
    return MoneysApiFp(this.configuration)
      .deleteLedgerById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MoneysApi
   */
  public deleteOperationById(id: string, options?: RawAxiosRequestConfig) {
    return MoneysApiFp(this.configuration)
      .deleteOperationById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MoneysApi
   */
  public deleteTicketById(id: string, options?: RawAxiosRequestConfig) {
    return MoneysApiFp(this.configuration)
      .deleteTicketById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} operationId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MoneysApi
   */
  public getAllOperationStaffs(
    operationId: string,
    options?: RawAxiosRequestConfig
  ) {
    return MoneysApiFp(this.configuration)
      .getAllOperationStaffs(operationId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} operationId
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MoneysApi
   */
  public getAllOperationTicketsStatus(
    operationId: string,
    page?: number,
    pageSize?: number,
    options?: RawAxiosRequestConfig
  ) {
    return MoneysApiFp(this.configuration)
      .getAllOperationTicketsStatus(operationId, page, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MoneysApi
   */
  public getLedgerById(id: string, options?: RawAxiosRequestConfig) {
    return MoneysApiFp(this.configuration)
      .getLedgerById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} [name]
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MoneysApi
   */
  public getLedgers(
    name?: string,
    page?: number,
    pageSize?: number,
    options?: RawAxiosRequestConfig
  ) {
    return MoneysApiFp(this.configuration)
      .getLedgers(name, page, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MoneysApi
   */
  public getOperationById(id: string, options?: RawAxiosRequestConfig) {
    return MoneysApiFp(this.configuration)
      .getOperationById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MoneysApi
   */
  public getOperationResults(
    page?: number,
    pageSize?: number,
    options?: RawAxiosRequestConfig
  ) {
    return MoneysApiFp(this.configuration)
      .getOperationResults(page, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} operationId
   * @param {number} ticketNumber
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MoneysApi
   */
  public getOperationTicketByTicketNumber(
    operationId: string,
    ticketNumber: number,
    options?: RawAxiosRequestConfig
  ) {
    return MoneysApiFp(this.configuration)
      .getOperationTicketByTicketNumber(operationId, ticketNumber, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} [name]
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MoneysApi
   */
  public getOperations(
    name?: string,
    page?: number,
    pageSize?: number,
    options?: RawAxiosRequestConfig
  ) {
    return MoneysApiFp(this.configuration)
      .getOperations(name, page, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} operationId
   * @param {string} staffId
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MoneysApi
   */
  public getPayedTickets(
    operationId: string,
    staffId: string,
    page?: number,
    pageSize?: number,
    options?: RawAxiosRequestConfig
  ) {
    return MoneysApiFp(this.configuration)
      .getPayedTickets(operationId, staffId, page, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MoneysApi
   */
  public getTicketById(id: string, options?: RawAxiosRequestConfig) {
    return MoneysApiFp(this.configuration)
      .getTicketById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MoneysApi
   */
  public getTickets(
    page?: number,
    pageSize?: number,
    options?: RawAxiosRequestConfig
  ) {
    return MoneysApiFp(this.configuration)
      .getTickets(page, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ResourcesApi - axios parameter creator
 * @export
 */
export const ResourcesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary
     * @param {Array<Association>} association
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateAssociations: async (
      association: Array<Association>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'association' is not null or undefined
      assertParamExists("crupdateAssociations", "association", association);
      const localVarPath = `/associations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        association,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {Array<Committee>} committee
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateCommittees: async (
      committee: Array<Committee>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'committee' is not null or undefined
      assertParamExists("crupdateCommittees", "committee", committee);
      const localVarPath = `/committees`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        committee,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {Array<Event>} event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateEvents: async (
      event: Array<Event>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'event' is not null or undefined
      assertParamExists("crupdateEvents", "event", event);
      const localVarPath = `/events`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        event,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {Array<Region>} region
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateRegions: async (
      region: Array<Region>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'region' is not null or undefined
      assertParamExists("crupdateRegions", "region", region);
      const localVarPath = `/regions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        region,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {Array<Responsability>} responsability
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateResponsabilities: async (
      responsability: Array<Responsability>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'responsability' is not null or undefined
      assertParamExists(
        "crupdateResponsabilities",
        "responsability",
        responsability
      );
      const localVarPath = `/responsabilities`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        responsability,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {Array<Sacrament>} sacrament
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateSacraments: async (
      sacrament: Array<Sacrament>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sacrament' is not null or undefined
      assertParamExists("crupdateSacraments", "sacrament", sacrament);
      const localVarPath = `/sacraments`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        sacrament,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAssociationById: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deleteAssociationById", "id", id);
      const localVarPath = `/associations/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCommitteeById: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deleteCommitteeById", "id", id);
      const localVarPath = `/committees/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteEventById: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deleteEventById", "id", id);
      const localVarPath = `/events/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRegionById: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deleteRegionById", "id", id);
      const localVarPath = `/regions/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteResponsabilityById: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deleteResponsabilityById", "id", id);
      const localVarPath = `/responsabilities/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSacramentById: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deleteSacramentById", "id", id);
      const localVarPath = `/sacraments/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAssociationById: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getAssociationById", "id", id);
      const localVarPath = `/associations/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAssociations: async (
      name?: string,
      page?: number,
      pageSize?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/associations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (name !== undefined) {
        localVarQueryParameter["name"] = name;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter["pageSize"] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCommitteeById: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getCommitteeById", "id", id);
      const localVarPath = `/committees/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCommittees: async (
      name?: string,
      page?: number,
      pageSize?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/committees`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (name !== undefined) {
        localVarQueryParameter["name"] = name;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter["pageSize"] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventById: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getEventById", "id", id);
      const localVarPath = `/events/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEvents: async (
      name?: string,
      page?: number,
      pageSize?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/events`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (name !== undefined) {
        localVarQueryParameter["name"] = name;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter["pageSize"] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRegionById: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getRegionById", "id", id);
      const localVarPath = `/regions/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRegions: async (
      name?: string,
      page?: number,
      pageSize?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/regions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (name !== undefined) {
        localVarQueryParameter["name"] = name;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter["pageSize"] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getResponsabilities: async (
      name?: string,
      page?: number,
      pageSize?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/responsabilities`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (name !== undefined) {
        localVarQueryParameter["name"] = name;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter["pageSize"] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getResponsabilityById: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getResponsabilityById", "id", id);
      const localVarPath = `/responsabilities/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSacramentById: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getSacramentById", "id", id);
      const localVarPath = `/sacraments/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSacraments: async (
      name?: string,
      page?: number,
      pageSize?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/sacraments`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (name !== undefined) {
        localVarQueryParameter["name"] = name;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter["pageSize"] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ResourcesApi - functional programming interface
 * @export
 */
export const ResourcesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ResourcesApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary
     * @param {Array<Association>} association
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async crupdateAssociations(
      association: Array<Association>,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<Association>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.crupdateAssociations(
          association,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResourcesApi.crupdateAssociations"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {Array<Committee>} committee
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async crupdateCommittees(
      committee: Array<Committee>,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<Committee>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.crupdateCommittees(committee, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResourcesApi.crupdateCommittees"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {Array<Event>} event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async crupdateEvents(
      event: Array<Event>,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.crupdateEvents(
        event,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResourcesApi.crupdateEvents"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {Array<Region>} region
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async crupdateRegions(
      region: Array<Region>,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Region>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.crupdateRegions(
        region,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResourcesApi.crupdateRegions"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {Array<Responsability>} responsability
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async crupdateResponsabilities(
      responsability: Array<Responsability>,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<Responsability>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.crupdateResponsabilities(
          responsability,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResourcesApi.crupdateResponsabilities"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {Array<Sacrament>} sacrament
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async crupdateSacraments(
      sacrament: Array<Sacrament>,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<Sacrament>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.crupdateSacraments(sacrament, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResourcesApi.crupdateSacraments"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteAssociationById(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Association>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteAssociationById(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResourcesApi.deleteAssociationById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteCommitteeById(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Committee>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteCommitteeById(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResourcesApi.deleteCommitteeById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteEventById(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEventById(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResourcesApi.deleteEventById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteRegionById(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Region>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteRegionById(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResourcesApi.deleteRegionById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteResponsabilityById(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Responsability>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteResponsabilityById(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResourcesApi.deleteResponsabilityById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteSacramentById(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sacrament>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteSacramentById(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResourcesApi.deleteSacramentById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAssociationById(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Association>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAssociationById(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResourcesApi.getAssociationById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAssociations(
      name?: string,
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<Association>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAssociations(
        name,
        page,
        pageSize,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResourcesApi.getAssociations"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCommitteeById(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Committee>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCommitteeById(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResourcesApi.getCommitteeById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCommittees(
      name?: string,
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<Committee>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCommittees(
        name,
        page,
        pageSize,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResourcesApi.getCommittees"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEventById(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEventById(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResourcesApi.getEventById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEvents(
      name?: string,
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEvents(
        name,
        page,
        pageSize,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResourcesApi.getEvents"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRegionById(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Region>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRegionById(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResourcesApi.getRegionById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRegions(
      name?: string,
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Region>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRegions(
        name,
        page,
        pageSize,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResourcesApi.getRegions"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getResponsabilities(
      name?: string,
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<Responsability>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getResponsabilities(
          name,
          page,
          pageSize,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResourcesApi.getResponsabilities"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getResponsabilityById(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Responsability>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getResponsabilityById(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResourcesApi.getResponsabilityById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSacramentById(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sacrament>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getSacramentById(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResourcesApi.getSacramentById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSacraments(
      name?: string,
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<Sacrament>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSacraments(
        name,
        page,
        pageSize,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ResourcesApi.getSacraments"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ResourcesApi - factory interface
 * @export
 */
export const ResourcesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ResourcesApiFp(configuration);
  return {
    /**
     *
     * @summary
     * @param {Array<Association>} association
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateAssociations(
      association: Array<Association>,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Association>> {
      return localVarFp
        .crupdateAssociations(association, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {Array<Committee>} committee
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateCommittees(
      committee: Array<Committee>,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Committee>> {
      return localVarFp
        .crupdateCommittees(committee, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {Array<Event>} event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateEvents(
      event: Array<Event>,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Event>> {
      return localVarFp
        .crupdateEvents(event, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {Array<Region>} region
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateRegions(
      region: Array<Region>,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Region>> {
      return localVarFp
        .crupdateRegions(region, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {Array<Responsability>} responsability
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateResponsabilities(
      responsability: Array<Responsability>,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Responsability>> {
      return localVarFp
        .crupdateResponsabilities(responsability, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {Array<Sacrament>} sacrament
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateSacraments(
      sacrament: Array<Sacrament>,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Sacrament>> {
      return localVarFp
        .crupdateSacraments(sacrament, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAssociationById(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Association> {
      return localVarFp
        .deleteAssociationById(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCommitteeById(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Committee> {
      return localVarFp
        .deleteCommitteeById(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteEventById(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Event> {
      return localVarFp
        .deleteEventById(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRegionById(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Region> {
      return localVarFp
        .deleteRegionById(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteResponsabilityById(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Responsability> {
      return localVarFp
        .deleteResponsabilityById(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSacramentById(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Sacrament> {
      return localVarFp
        .deleteSacramentById(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAssociationById(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Association> {
      return localVarFp
        .getAssociationById(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAssociations(
      name?: string,
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Association>> {
      return localVarFp
        .getAssociations(name, page, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCommitteeById(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Committee> {
      return localVarFp
        .getCommitteeById(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCommittees(
      name?: string,
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Committee>> {
      return localVarFp
        .getCommittees(name, page, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventById(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Event> {
      return localVarFp
        .getEventById(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEvents(
      name?: string,
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Event>> {
      return localVarFp
        .getEvents(name, page, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRegionById(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Region> {
      return localVarFp
        .getRegionById(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRegions(
      name?: string,
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Region>> {
      return localVarFp
        .getRegions(name, page, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getResponsabilities(
      name?: string,
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Responsability>> {
      return localVarFp
        .getResponsabilities(name, page, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getResponsabilityById(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Responsability> {
      return localVarFp
        .getResponsabilityById(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSacramentById(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Sacrament> {
      return localVarFp
        .getSacramentById(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSacraments(
      name?: string,
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Sacrament>> {
      return localVarFp
        .getSacraments(name, page, pageSize, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ResourcesApi - object-oriented interface
 * @export
 * @class ResourcesApi
 * @extends {BaseAPI}
 */
export class ResourcesApi extends BaseAPI {
  /**
   *
   * @summary
   * @param {Array<Association>} association
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public crupdateAssociations(
    association: Array<Association>,
    options?: RawAxiosRequestConfig
  ) {
    return ResourcesApiFp(this.configuration)
      .crupdateAssociations(association, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {Array<Committee>} committee
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public crupdateCommittees(
    committee: Array<Committee>,
    options?: RawAxiosRequestConfig
  ) {
    return ResourcesApiFp(this.configuration)
      .crupdateCommittees(committee, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {Array<Event>} event
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public crupdateEvents(event: Array<Event>, options?: RawAxiosRequestConfig) {
    return ResourcesApiFp(this.configuration)
      .crupdateEvents(event, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {Array<Region>} region
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public crupdateRegions(
    region: Array<Region>,
    options?: RawAxiosRequestConfig
  ) {
    return ResourcesApiFp(this.configuration)
      .crupdateRegions(region, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {Array<Responsability>} responsability
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public crupdateResponsabilities(
    responsability: Array<Responsability>,
    options?: RawAxiosRequestConfig
  ) {
    return ResourcesApiFp(this.configuration)
      .crupdateResponsabilities(responsability, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {Array<Sacrament>} sacrament
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public crupdateSacraments(
    sacrament: Array<Sacrament>,
    options?: RawAxiosRequestConfig
  ) {
    return ResourcesApiFp(this.configuration)
      .crupdateSacraments(sacrament, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public deleteAssociationById(id: string, options?: RawAxiosRequestConfig) {
    return ResourcesApiFp(this.configuration)
      .deleteAssociationById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public deleteCommitteeById(id: string, options?: RawAxiosRequestConfig) {
    return ResourcesApiFp(this.configuration)
      .deleteCommitteeById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public deleteEventById(id: string, options?: RawAxiosRequestConfig) {
    return ResourcesApiFp(this.configuration)
      .deleteEventById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public deleteRegionById(id: string, options?: RawAxiosRequestConfig) {
    return ResourcesApiFp(this.configuration)
      .deleteRegionById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public deleteResponsabilityById(id: string, options?: RawAxiosRequestConfig) {
    return ResourcesApiFp(this.configuration)
      .deleteResponsabilityById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public deleteSacramentById(id: string, options?: RawAxiosRequestConfig) {
    return ResourcesApiFp(this.configuration)
      .deleteSacramentById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public getAssociationById(id: string, options?: RawAxiosRequestConfig) {
    return ResourcesApiFp(this.configuration)
      .getAssociationById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} [name]
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public getAssociations(
    name?: string,
    page?: number,
    pageSize?: number,
    options?: RawAxiosRequestConfig
  ) {
    return ResourcesApiFp(this.configuration)
      .getAssociations(name, page, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public getCommitteeById(id: string, options?: RawAxiosRequestConfig) {
    return ResourcesApiFp(this.configuration)
      .getCommitteeById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} [name]
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public getCommittees(
    name?: string,
    page?: number,
    pageSize?: number,
    options?: RawAxiosRequestConfig
  ) {
    return ResourcesApiFp(this.configuration)
      .getCommittees(name, page, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public getEventById(id: string, options?: RawAxiosRequestConfig) {
    return ResourcesApiFp(this.configuration)
      .getEventById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} [name]
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public getEvents(
    name?: string,
    page?: number,
    pageSize?: number,
    options?: RawAxiosRequestConfig
  ) {
    return ResourcesApiFp(this.configuration)
      .getEvents(name, page, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public getRegionById(id: string, options?: RawAxiosRequestConfig) {
    return ResourcesApiFp(this.configuration)
      .getRegionById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} [name]
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public getRegions(
    name?: string,
    page?: number,
    pageSize?: number,
    options?: RawAxiosRequestConfig
  ) {
    return ResourcesApiFp(this.configuration)
      .getRegions(name, page, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} [name]
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public getResponsabilities(
    name?: string,
    page?: number,
    pageSize?: number,
    options?: RawAxiosRequestConfig
  ) {
    return ResourcesApiFp(this.configuration)
      .getResponsabilities(name, page, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public getResponsabilityById(id: string, options?: RawAxiosRequestConfig) {
    return ResourcesApiFp(this.configuration)
      .getResponsabilityById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public getSacramentById(id: string, options?: RawAxiosRequestConfig) {
    return ResourcesApiFp(this.configuration)
      .getSacramentById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} [name]
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public getSacraments(
    name?: string,
    page?: number,
    pageSize?: number,
    options?: RawAxiosRequestConfig
  ) {
    return ResourcesApiFp(this.configuration)
      .getSacraments(name, page, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SecurityApi - axios parameter creator
 * @export
 */
export const SecurityApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary
     * @param {SigninPayload} signinPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signin: async (
      signinPayload: SigninPayload,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'signinPayload' is not null or undefined
      assertParamExists("signin", "signinPayload", signinPayload);
      const localVarPath = `/signin`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        signinPayload,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {SignupPayload} signupPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signup: async (
      signupPayload: SignupPayload,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'signupPayload' is not null or undefined
      assertParamExists("signup", "signupPayload", signupPayload);
      const localVarPath = `/signup`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        signupPayload,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Tell who you are
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    whoami: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/whoami`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SecurityApi - functional programming interface
 * @export
 */
export const SecurityApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SecurityApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary
     * @param {SigninPayload} signinPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async signin(
      signinPayload: SigninPayload,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Whoami>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.signin(
        signinPayload,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SecurityApi.signin"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {SignupPayload} signupPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async signup(
      signupPayload: SignupPayload,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Whoami>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.signup(
        signupPayload,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SecurityApi.signup"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Tell who you are
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async whoami(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Whoami>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.whoami(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SecurityApi.whoami"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * SecurityApi - factory interface
 * @export
 */
export const SecurityApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = SecurityApiFp(configuration);
  return {
    /**
     *
     * @summary
     * @param {SigninPayload} signinPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signin(
      signinPayload: SigninPayload,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Whoami> {
      return localVarFp
        .signin(signinPayload, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {SignupPayload} signupPayload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signup(
      signupPayload: SignupPayload,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Whoami> {
      return localVarFp
        .signup(signupPayload, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Tell who you are
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    whoami(options?: RawAxiosRequestConfig): AxiosPromise<Whoami> {
      return localVarFp
        .whoami(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * SecurityApi - object-oriented interface
 * @export
 * @class SecurityApi
 * @extends {BaseAPI}
 */
export class SecurityApi extends BaseAPI {
  /**
   *
   * @summary
   * @param {SigninPayload} signinPayload
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityApi
   */
  public signin(signinPayload: SigninPayload, options?: RawAxiosRequestConfig) {
    return SecurityApiFp(this.configuration)
      .signin(signinPayload, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {SignupPayload} signupPayload
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityApi
   */
  public signup(signupPayload: SignupPayload, options?: RawAxiosRequestConfig) {
    return SecurityApiFp(this.configuration)
      .signup(signupPayload, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Tell who you are
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityApi
   */
  public whoami(options?: RawAxiosRequestConfig) {
    return SecurityApiFp(this.configuration)
      .whoami(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary
     * @param {Array<Role>} role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateRoles: async (
      role: Array<Role>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'role' is not null or undefined
      assertParamExists("crupdateRoles", "role", role);
      const localVarPath = `/roles`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        role,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRoleById: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deleteRoleById", "id", id);
      const localVarPath = `/roles/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRoleById: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getRoleById", "id", id);
      const localVarPath = `/roles/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRoles: async (
      name?: string,
      page?: number,
      pageSize?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/roles`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (name !== undefined) {
        localVarQueryParameter["name"] = name;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter["pageSize"] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserById: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getUserById", "id", id);
      const localVarPath = `/users/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} [lastName]
     * @param {string} [firstName]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers: async (
      lastName?: string,
      firstName?: string,
      page?: number,
      pageSize?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (lastName !== undefined) {
        localVarQueryParameter["lastName"] = lastName;
      }

      if (firstName !== undefined) {
        localVarQueryParameter["firstName"] = firstName;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter["pageSize"] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary
     * @param {Array<Role>} role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async crupdateRoles(
      role: Array<Role>,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Role>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.crupdateRoles(
        role,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UsersApi.crupdateRoles"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteRoleById(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRoleById(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UsersApi.deleteRoleById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRoleById(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRoleById(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UsersApi.getRoleById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRoles(
      name?: string,
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Role>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRoles(
        name,
        page,
        pageSize,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UsersApi.getRoles"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserById(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUserById(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UsersApi.getUserById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} [lastName]
     * @param {string} [firstName]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUsers(
      lastName?: string,
      firstName?: string,
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(
        lastName,
        firstName,
        page,
        pageSize,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UsersApi.getUsers"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = UsersApiFp(configuration);
  return {
    /**
     *
     * @summary
     * @param {Array<Role>} role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateRoles(
      role: Array<Role>,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Role>> {
      return localVarFp
        .crupdateRoles(role, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRoleById(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Role> {
      return localVarFp
        .deleteRoleById(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRoleById(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Role> {
      return localVarFp
        .getRoleById(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRoles(
      name?: string,
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<Role>> {
      return localVarFp
        .getRoles(name, page, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserById(
      id: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<User> {
      return localVarFp
        .getUserById(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} [lastName]
     * @param {string} [firstName]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers(
      lastName?: string,
      firstName?: string,
      page?: number,
      pageSize?: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Array<User>> {
      return localVarFp
        .getUsers(lastName, firstName, page, pageSize, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
  /**
   *
   * @summary
   * @param {Array<Role>} role
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public crupdateRoles(role: Array<Role>, options?: RawAxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .crupdateRoles(role, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public deleteRoleById(id: string, options?: RawAxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .deleteRoleById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getRoleById(id: string, options?: RawAxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .getRoleById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} [name]
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getRoles(
    name?: string,
    page?: number,
    pageSize?: number,
    options?: RawAxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .getRoles(name, page, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getUserById(id: string, options?: RawAxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .getUserById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} [lastName]
   * @param {string} [firstName]
   * @param {number} [page]
   * @param {number} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getUsers(
    lastName?: string,
    firstName?: string,
    page?: number,
    pageSize?: number,
    options?: RawAxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .getUsers(lastName, firstName, page, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
